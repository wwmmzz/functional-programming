"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[69],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=r,f=u["".concat(l,".").concat(d)]||u[d]||c[d]||o;return t?a.createElement(f,i(i({ref:n},m),{},{components:t})):a.createElement(f,i({ref:n},m))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5057:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const o={},i="Functors",s={unversionedId:"Functors",id:"Functors",title:"Functors",description:"In the last section we've spoken about the TS category (the TypeScript category) and about function composition's core problem:",source:"@site/docs/9. Functors.md",sourceDirName:".",slug:"/Functors",permalink:"/functional-programming/Functors",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Category theory",permalink:"/functional-programming/Category theory"},next:{title:"Applicative functors",permalink:"/functional-programming/Applicative functors"}},l={},p=[{value:"Functions as programs",id:"functions-as-programs",level:2},{value:"A boundary that leads to functors",id:"a-boundary-that-leads-to-functors",level:2},{value:"Definition",id:"definition",level:2},{value:"Functors and functional error handling",id:"functors-and-functional-error-handling",level:2},{value:"Functors compose",id:"functors-compose",level:2},{value:"Contravariant Functors",id:"contravariant-functors",level:2},{value:"Functors in <code>fp-ts</code>",id:"functors-in-fp-ts",level:2},{value:"Do functors solve the general problem?",id:"do-functors-solve-the-general-problem",level:2}],m={toc:p},u="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"functors"},"Functors"),(0,r.kt)("p",null,"In the last section we've spoken about the ",(0,r.kt)("em",{parentName:"p"},"TS")," category (the TypeScript category) and about function composition's core problem:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"How can we compose two generic functions ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => B")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (c: C) => D"),"?")),(0,r.kt)("p",null,"Why is finding solutions to this problem so important?"),(0,r.kt)("p",null,"Because, if it is true that categories can be used to model programming languages, morphisms (functions in the ",(0,r.kt)("em",{parentName:"p"},"TS")," category) can be used to model ",(0,r.kt)("strong",{parentName:"p"},"programs"),"."),(0,r.kt)("p",null,"Thus, solving this abstract problem means finding a concrete way of ",(0,r.kt)("strong",{parentName:"p"},"composing programs in a generic way"),". And ",(0,r.kt)("em",{parentName:"p"},"that")," is really interesting for us developers, isn't it?"),(0,r.kt)("h2",{id:"functions-as-programs"},"Functions as programs"),(0,r.kt)("p",null,"If we want to model programs with functions we need to tackle an issue immediately:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"How is it possible to model a program that produces side effects with a pure function?")),(0,r.kt)("p",null,"The answer is to model side effects through ",(0,r.kt)("strong",{parentName:"p"},"effects"),", meaning types that ",(0,r.kt)("strong",{parentName:"p"},"represent")," side effects."),(0,r.kt)("p",null,"Let's see two possible techniques to do so in JavaScript:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"define a DSL (domain specific language) for effects"),(0,r.kt)("li",{parentName:"ul"},"use a ",(0,r.kt)("em",{parentName:"li"},"thunk"))),(0,r.kt)("p",null,"The first technique, using a DSL, means modifying a program like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function log(message: string): void {\n  console.log(message) // side effect\n}\n")),(0,r.kt)("p",null,"changing its codomain to make the function return a ",(0,r.kt)("strong",{parentName:"p"},"description")," of the side effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type DSL = ... // sum type of every possible effect handled by the system\n\nfunction log(message: string): DSL {\n  return {\n    type: "log",\n    message\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Is the freshly defined ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," function really pure? Actually ",(0,r.kt)("inlineCode",{parentName:"p"},"log('foo') !== log('foo')"),"!"),(0,r.kt)("p",null,"This technique requires a way to combine effects and the definition of an interpreter able to execute the side effects when launching the final program."),(0,r.kt)("p",null,"The second technique, way simpler in TypeScript, is to enclose the computation in a ",(0,r.kt)("em",{parentName:"p"},"thunk"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// a thunk representing a synchronous side effect\ntype IO<A> = () => A\n\nconst log = (message: string): IO<void> => {\n  return () => console.log(message) // returns a thunk\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," program, once executed, won't cause immediately a side effect, but returns ",(0,r.kt)("strong",{parentName:"p"},"a value representing the computation")," (also known as ",(0,r.kt)("em",{parentName:"p"},"action"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\n\nexport const log = (message: string): IO<void> => {\n  return () => console.log(message) // returns a thunk\n}\n\nexport const main = log('hello!')\n// there's nothing in the output at this point\n// because `main` is only an inert value\n// representing the computation\n\nmain()\n// only when launching the program I will see the result\n")),(0,r.kt)("p",null,"In functional programming there's a tendency to shove side effects (under the form of effects) to the border of the system (the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function) where they are executed by an interpreter obtaining the following schema:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"system = pure core + imperative shell")),(0,r.kt)("p",null,"In ",(0,r.kt)("em",{parentName:"p"},"purely functional")," languages (like Haskell, PureScript or Elm) this division is strict and clear and imposed by the very languages."),(0,r.kt)("p",null,"Even with this thunk technique (the same technique used in ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts"),") we need a way to combine effects, which brings us back to our goal of composing programs in a generic way, let's see how."),(0,r.kt)("p",null,"We first need a bit of (informal) terminology: we'll call ",(0,r.kt)("strong",{parentName:"p"},"pure program")," a function with the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"(a: A) => B\n")),(0,r.kt)("p",null,"Such a signature models a program that takes an input of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and returns a result of type ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," without any effect."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"len")," program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const len = (s: string): number => s.length\n")),(0,r.kt)("p",null,"We'll call an ",(0,r.kt)("strong",{parentName:"p"},"effectful program")," a function with the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"(a: A) => F<B>\n")),(0,r.kt)("p",null,"Such a signature models a program that takes an input of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and returns a result of type ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," together with an ",(0,r.kt)("strong",{parentName:"p"},"effect")," ",(0,r.kt)("inlineCode",{parentName:"p"},"F"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," is some sort of type constructor."),(0,r.kt)("p",null,"Let's recall that a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Type_constructor"},"type constructor")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"-ary type operator that takes as argument one or more types and returns another type. We have seen examples of such constructors as ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyArray"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Option, some, none } from 'fp-ts/Option'\n\nconst head = <A>(as: ReadonlyArray<A>): Option<A> =>\n  as.length === 0 ? none : some(as[0])\n")),(0,r.kt)("p",null,"is a program with an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," effect."),(0,r.kt)("p",null,"When we talk about effects we are interested in ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"-ary type constructors where ",(0,r.kt)("inlineCode",{parentName:"p"},"n >= 1"),", example given:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type constructor"),(0,r.kt)("th",{parentName:"tr",align:null},"Effect (interpretation)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ReadonlyArray<A>")),(0,r.kt)("td",{parentName:"tr",align:null},"a non deterministic computation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Option<A>")),(0,r.kt)("td",{parentName:"tr",align:null},"a computation that may fail")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Either<E, A>")),(0,r.kt)("td",{parentName:"tr",align:null},"a computation that may fail")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"IO<A>")),(0,r.kt)("td",{parentName:"tr",align:null},"a synchronous computation that ",(0,r.kt)("strong",{parentName:"td"},"never fails"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Task<A>")),(0,r.kt)("td",{parentName:"tr",align:null},"an asynchronous computation ",(0,r.kt)("strong",{parentName:"td"},"never fails"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Reader<R, A>")),(0,r.kt)("td",{parentName:"tr",align:null},"reading from an environment")))),(0,r.kt)("p",null,"where"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// a thunk returning a `Promise`\ntype Task<A> = () => Promise<A>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// `R` represents an "environment" needed for the computation\n// (we can "read" from it) and `A` is the result\ntype Reader<R, A> = (r: R) => A\n')),(0,r.kt)("p",null,"Let's get back to our core problem:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"How do we compose two generic functions ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => B")," e ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (c: C) => D"),"?")),(0,r.kt)("p",null,"With our current set of rules this general problem is not solvable. We need to add some ",(0,r.kt)("em",{parentName:"p"},"boundaries")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),"."),(0,r.kt)("p",null,"We already know that if ",(0,r.kt)("inlineCode",{parentName:"p"},"B = C")," then the solution is the usual function composition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function flow<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C {\n  return (a) => g(f(a))\n}\n")),(0,r.kt)("p",null,"But what about other cases?"),(0,r.kt)("h2",{id:"a-boundary-that-leads-to-functors"},"A boundary that leads to functors"),(0,r.kt)("p",null,"Let's consider the following boundary: ",(0,r.kt)("inlineCode",{parentName:"p"},"B = F<C>")," for some type constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"F"),", we have the following situation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"f: (a: A) => F<B>")," is an effectful program"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"g: (b: B) => C")," is a pure program")),(0,r.kt)("p",null,"In order to compose ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," we need to find a procedure that allows us to derive a function ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," from a function ",(0,r.kt)("inlineCode",{parentName:"p"},"(b: B) => C")," to a function ",(0,r.kt)("inlineCode",{parentName:"p"},"(fb: F<B>) => F<C>")," in order to use the usual function composition (this way the codomain of ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," would be the same of the new function's domain)."),(0,r.kt)("img",{src:"images/map.png",width:"500",alt:"map"}),(0,r.kt)("p",null,"We have mutated the original problem in a new one: can we find a function, let's call it ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", that operates this way?"),(0,r.kt)("p",null,"Let's see some practical example:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = ReadonlyArray"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow, pipe } from 'fp-ts/function'\n\n// transforms functions `B -> C` to functions `ReadonlyArray<B> -> ReadonlyArray<C>`\nconst map = <B, C>(g: (b: B) => C) => (\n  fb: ReadonlyArray<B>\n): ReadonlyArray<C> => fb.map(g)\n\n// -------------------\n// usage example\n// -------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst getFollowers = (user: User): ReadonlyArray<User> => user.followers\nconst getName = (user: User): string => user.name\n\n// getFollowersNames: User -> ReadonlyArray<string>\nconst getFollowersNames = flow(getFollowers, map(getName))\n\n// let's use `pipe` instead of `flow`...\nexport const getFollowersNames2 = (user: User) =>\n  pipe(user, getFollowers, map(getName))\n\nconst user: User = {\n  id: 1,\n  name: 'Ruth R. Gonzalez',\n  followers: [\n    { id: 2, name: 'Terry R. Emerson', followers: [] },\n    { id: 3, name: 'Marsha J. Joslyn', followers: [] }\n  ]\n}\n\nconsole.log(getFollowersNames(user)) // => [ 'Terry R. Emerson', 'Marsha J. Joslyn' ]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Option"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport { none, Option, match, some } from 'fp-ts/Option'\n\n// transforms functions `B -> C` to functions `Option<B> -> Option<C>`\nconst map = <B, C>(g: (b: B) => C): ((fb: Option<B>) => Option<C>) =>\n  match(\n    () => none,\n    (b) => {\n      const c = g(b)\n      return some(c)\n    }\n  )\n\n// -------------------\n// usage example\n// -------------------\n\nimport * as RA from 'fp-ts/ReadonlyArray'\n\nconst head: (input: ReadonlyArray<number>) => Option<number> = RA.head\nconst double = (n: number): number => n * 2\n\n// getDoubleHead: ReadonlyArray<number> -> Option<number>\nconst getDoubleHead = flow(head, map(double))\n\nconsole.log(getDoubleHead([1, 2, 3])) // => some(2)\nconsole.log(getDoubleHead([])) // => none\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = IO"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport { IO } from 'fp-ts/IO'\n\n// transforms functions `B -> C` to functions `IO<B> -> IO<C>`\nconst map = <B, C>(g: (b: B) => C) => (fb: IO<B>): IO<C> => () => {\n  const b = fb()\n  return g(b)\n}\n\n// -------------------\n// usage example\n// -------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n}\n\n// a dummy in-memory database\nconst database: Record<number, User> = {\n  1: { id: 1, name: 'Ruth R. Gonzalez' },\n  2: { id: 2, name: 'Terry R. Emerson' },\n  3: { id: 3, name: 'Marsha J. Joslyn' }\n}\n\nconst getUser = (id: number): IO<User> => () => database[id]\nconst getName = (user: User): string => user.name\n\n// getUserName: number -> IO<string>\nconst getUserName = flow(getUser, map(getName))\n\nconsole.log(getUserName(1)()) // => Ruth R. Gonzalez\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Task"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport { Task } from 'fp-ts/Task'\n\n// transforms functions `B -> C` into functions `Task<B> -> Task<C>`\nconst map = <B, C>(g: (b: B) => C) => (fb: Task<B>): Task<C> => () => {\n  const promise = fb()\n  return promise.then(g)\n}\n\n// -------------------\n// usage example\n// -------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n}\n\n// a dummy remote database\nconst database: Record<number, User> = {\n  1: { id: 1, name: 'Ruth R. Gonzalez' },\n  2: { id: 2, name: 'Terry R. Emerson' },\n  3: { id: 3, name: 'Marsha J. Joslyn' }\n}\n\nconst getUser = (id: number): Task<User> => () => Promise.resolve(database[id])\nconst getName = (user: User): string => user.name\n\n// getUserName: number -> Task<string>\nconst getUserName = flow(getUser, map(getName))\n\ngetUserName(1)().then(console.log) // => Ruth R. Gonzalez\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Reader"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport { Reader } from 'fp-ts/Reader'\n\n// transforms functions `B -> C` into functions `Reader<R, B> -> Reader<R, C>`\nconst map = <B, C>(g: (b: B) => C) => <R>(fb: Reader<R, B>): Reader<R, C> => (\n  r\n) => {\n  const b = fb(r)\n  return g(b)\n}\n\n// -------------------\n// usage example\n// -------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n}\n\ninterface Env {\n  // a dummy in-memory database\n  readonly database: Record<string, User>\n}\n\nconst getUser = (id: number): Reader<Env, User> => (env) => env.database[id]\nconst getName = (user: User): string => user.name\n\n// getUserName: number -> Reader<Env, string>\nconst getUserName = flow(getUser, map(getName))\n\nconsole.log(\n  getUserName(1)({\n    database: {\n      1: { id: 1, name: 'Ruth R. Gonzalez' },\n      2: { id: 2, name: 'Terry R. Emerson' },\n      3: { id: 3, name: 'Marsha J. Joslyn' }\n    }\n  })\n) // => Ruth R. Gonzalez\n")),(0,r.kt)("p",null,"More generally, when a type constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," admits a ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," function, we say it admits a ",(0,r.kt)("strong",{parentName:"p"},"functor instance"),"."),(0,r.kt)("p",null,"From a mathematical point of view, functors are ",(0,r.kt)("strong",{parentName:"p"},"maps between categories")," that preserve the structure of the category, meaning they preserve the identity morphisms and the composition operation."),(0,r.kt)("p",null,"Since categories are pairs of objects and morphisms, a functor too is a pair of two things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("strong",{parentName:"li"},"map between objects")," that binds every object ",(0,r.kt)("inlineCode",{parentName:"li"},"X")," in ",(0,r.kt)("em",{parentName:"li"},"C")," to an object in ",(0,r.kt)("em",{parentName:"li"},"D"),"."),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("strong",{parentName:"li"},"map between morphisms")," that binds every morphism ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," in ",(0,r.kt)("em",{parentName:"li"},"C")," to a morphism ",(0,r.kt)("inlineCode",{parentName:"li"},"map(f)")," in ",(0,r.kt)("em",{parentName:"li"},"D"),".")),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"C")," e ",(0,r.kt)("em",{parentName:"p"},"D")," are two categories (aka two programming languages)."),(0,r.kt)("img",{src:"images/functor.png",width:"500",alt:"functor"}),(0,r.kt)("p",null,"Even though a map between two different programming languages is a fascinating idea, we're more interested in a map where ",(0,r.kt)("em",{parentName:"p"},"C")," and ",(0,r.kt)("em",{parentName:"p"},"D")," are the same (the ",(0,r.kt)("em",{parentName:"p"},"TS")," category). In that case we're talking about ",(0,r.kt)("strong",{parentName:"p"},"endofunctors"),' (from the greek "endo" meaning "inside", "internal").'),(0,r.kt)("p",null,'From now on, unless specified differently, when we write "functor" we mean an endofunctor in the ',(0,r.kt)("em",{parentName:"p"},"TS")," category."),(0,r.kt)("p",null,"Now we know the practical side of functors, let's see the formal definition."),(0,r.kt)("h2",{id:"definition"},"Definition"),(0,r.kt)("p",null,"A functor is a pair ",(0,r.kt)("inlineCode",{parentName:"p"},"(F, map)")," where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"F")," is an ",(0,r.kt)("inlineCode",{parentName:"li"},"n"),"-ary (",(0,r.kt)("inlineCode",{parentName:"li"},"n >= 1"),") type constructor mapping every type ",(0,r.kt)("inlineCode",{parentName:"li"},"X")," in a type ",(0,r.kt)("inlineCode",{parentName:"li"},"F<X>")," (",(0,r.kt)("strong",{parentName:"li"},"map between objects"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"map")," is a function with the following signature:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"map: <A, B>(f: (a: A) => B) => ((fa: F<A>) => F<B>)\n")),(0,r.kt)("p",null,"that maps every function ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => B")," in a function ",(0,r.kt)("inlineCode",{parentName:"p"},"map(f): (fa: F<A>) => F<B>")," (",(0,r.kt)("strong",{parentName:"p"},"map between morphism"),")"),(0,r.kt)("p",null,"The following properties have to hold true:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"map(1"),(0,r.kt)("sub",null,"X"),(0,r.kt)("inlineCode",{parentName:"li"},")")," = ",(0,r.kt)("inlineCode",{parentName:"li"},"1"),(0,r.kt)("sub",null,"F(X)")," (",(0,r.kt)("strong",{parentName:"li"},"identities go to identities"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"map(g \u2218 f) = map(g) \u2218 map(f)")," (",(0,r.kt)("strong",{parentName:"li"},"the image of a composition is the composition of its images"),")")),(0,r.kt)("p",null,"The second law allows to refactor and optimize the following computation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow, increment, pipe } from 'fp-ts/function'\nimport { map } from 'fp-ts/ReadonlyArray'\n\nconst double = (n: number): number => n * 2\n\n// iterates array twice\nconsole.log(pipe([1, 2, 3], map(double), map(increment))) // => [ 3, 5, 7 ]\n\n// single iteration\nconsole.log(pipe([1, 2, 3], map(flow(double, increment)))) // => [ 3, 5, 7 ]\n")),(0,r.kt)("h2",{id:"functors-and-functional-error-handling"},"Functors and functional error handling"),(0,r.kt)("p",null,"Functors have a positive impact on functional error handling, let's see a practical example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const doSomethingWithIndex: (index: number) => string\n\nexport const program = (ns: ReadonlyArray<number>): string => {\n  // -1 indicates that no element has been found\n  const i = ns.findIndex((n) => n > 0)\n  if (i !== -1) {\n    return doSomethingWithIndex(i)\n  }\n  throw new Error('cannot find a positive number')\n}\n")),(0,r.kt)("p",null,"Using the native ",(0,r.kt)("inlineCode",{parentName:"p"},"findIndex")," API we are forced to use an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," branch to test whether we have a result different than ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),". If we forget to do so, the value ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," could be unintentionally passed as input to ",(0,r.kt)("inlineCode",{parentName:"p"},"doSomethingWithIndex"),"."),(0,r.kt)("p",null,"Let's see how easier it is to obtain the same behavior using ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," and its functor instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport { map, Option } from 'fp-ts/Option'\nimport { findIndex } from 'fp-ts/ReadonlyArray'\n\ndeclare const doSomethingWithIndex: (index: number) => string\n\nexport const program = (ns: ReadonlyArray<number>): Option<string> =>\n  pipe(\n    ns,\n    findIndex((n) => n > 0),\n    map(doSomethingWithIndex)\n  )\n")),(0,r.kt)("p",null,"Practically, using ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),", we're always in front of the ",(0,r.kt)("inlineCode",{parentName:"p"},"happy path"),", error handing happens behind the scenes thanks to ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Demo")," (optional)"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/enricopolanski/functional-programming/blob/master/src/04_functor.ts"},(0,r.kt)("inlineCode",{parentName:"a"},"04_functor.ts"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Task<A>")," represents an asynchronous call that always succeed, how can we model a computation that can fail instead?"),(0,r.kt)("h2",{id:"functors-compose"},"Functors compose"),(0,r.kt)("p",null,"Functors compose, meaning that given two functors ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"G")," then the composition ",(0,r.kt)("inlineCode",{parentName:"p"},"F<G<A>>")," is still a functor and the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," of this composition is the composition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),"s."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Task"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"G = Option"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as T from 'fp-ts/Task'\n\ntype TaskOption<A> = T.Task<O.Option<A>>\n\nexport const map: <A, B>(\n  f: (a: A) => B\n) => (fa: TaskOption<A>) => TaskOption<B> = flow(O.map, T.map)\n\n// -------------------\n// usage example\n// -------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n}\n\n// a dummy remote database\nconst database: Record<number, User> = {\n  1: { id: 1, name: 'Ruth R. Gonzalez' },\n  2: { id: 2, name: 'Terry R. Emerson' },\n  3: { id: 3, name: 'Marsha J. Joslyn' }\n}\n\nconst getUser = (id: number): TaskOption<User> => () =>\n  Promise.resolve(O.fromNullable(database[id]))\nconst getName = (user: User): string => user.name\n\n// getUserName: number -> TaskOption<string>\nconst getUserName = flow(getUser, map(getName))\n\ngetUserName(1)().then(console.log) // => some('Ruth R. Gonzalez')\ngetUserName(4)().then(console.log) // => none\n")),(0,r.kt)("h2",{id:"contravariant-functors"},"Contravariant Functors"),(0,r.kt)("p",null,'In the previous section we haven\'t been completely thorough with our definitions. What we have seen in the previous section and called "functors" should be more properly called ',(0,r.kt)("strong",{parentName:"p"},"covariant functors"),"."),(0,r.kt)("p",null,"In this section we'll see another variant of the functor concept, ",(0,r.kt)("strong",{parentName:"p"},"contravariant")," functors."),(0,r.kt)("p",null,"The definition of a contravariant functor is pretty much the same of the covariant one, except for the signature of its fundamental operation, which is called ",(0,r.kt)("inlineCode",{parentName:"p"},"contramap")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,r.kt)("img",{src:"images/contramap.png",width:"300",alt:"contramap"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { map } from 'fp-ts/Option'\nimport { contramap } from 'fp-ts/Eq'\n\ntype User = {\n  readonly id: number\n  readonly name: string\n}\n\nconst getId = (_: User): number => _.id\n\n// the way `map` operates...\n// const getIdOption: (fa: Option<User>) => Option<number>\nconst getIdOption = map(getId)\n\n// the way `contramap` operates...\n// const getIdEq: (fa: Eq<number>) => Eq<User>\nconst getIdEq = contramap(getId)\n\nimport * as N from 'fp-ts/number'\n\nconst EqID = getIdEq(N.Eq)\n\n/*\n\nIn the `Eq` chapter we saw:\n\nconst EqID: Eq<User> = pipe(\n  N.Eq,\n  contramap((_: User) => _.id)\n)\n*/\n")),(0,r.kt)("h2",{id:"functors-in-fp-ts"},"Functors in ",(0,r.kt)("inlineCode",{parentName:"h2"},"fp-ts")),(0,r.kt)("p",null,"How do we define a functor instance in ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts"),"? Let's see some example."),(0,r.kt)("p",null,"The following interface represents the model of some result we get by calling some HTTP API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface Response<A> {\n  url: string\n  status: number\n  headers: Record<string, string>\n  body: A\n}\n")),(0,r.kt)("p",null,"Please note that since ",(0,r.kt)("inlineCode",{parentName:"p"},"body")," is parametric, this makes ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," a good candidate to find a functor instance given that ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," is a an ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"-ary type constructor with ",(0,r.kt)("inlineCode",{parentName:"p"},"n >= 1")," (a necessary condition)."),(0,r.kt)("p",null,"To define a functor instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," we need to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," function along some ",(0,r.kt)("a",{parentName:"p",href:"https://gcanti.github.io/fp-ts/recipes/HKT.html"},"technical details")," required by ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// `Response.ts` module\n\nimport { pipe } from 'fp-ts/function'\nimport { Functor1 } from 'fp-ts/Functor'\n\ndeclare module 'fp-ts/HKT' {\n  interface URItoKind<A> {\n    readonly Response: Response<A>\n  }\n}\n\nexport interface Response<A> {\n  readonly url: string\n  readonly status: number\n  readonly headers: Record<string, string>\n  readonly body: A\n}\n\nexport const map = <A, B>(f: (a: A) => B) => (\n  fa: Response<A>\n): Response<B> => ({\n  ...fa,\n  body: f(fa.body)\n})\n\n// functor instance for `Response<A>`\nexport const Functor: Functor1<'Response'> = {\n  URI: 'Response',\n  map: (fa, f) => pipe(fa, map(f))\n}\n")),(0,r.kt)("h2",{id:"do-functors-solve-the-general-problem"},"Do functors solve the general problem?"),(0,r.kt)("p",null,"Not yet. Functors allow us to compose an effectful program ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," with a pure program ",(0,r.kt)("inlineCode",{parentName:"p"},"g"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," has to be a ",(0,r.kt)("strong",{parentName:"p"},"unary")," function, accepting one single argument. What happens if ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," takes two or more arguments?"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Program f"),(0,r.kt)("th",{parentName:"tr",align:null},"Program g"),(0,r.kt)("th",{parentName:"tr",align:null},"Composition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"g \u2218 f"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"effectful"),(0,r.kt)("td",{parentName:"tr",align:null},"pure (unary)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map(g) \u2218 f"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"effectful"),(0,r.kt)("td",{parentName:"tr",align:null},"pure (",(0,r.kt)("inlineCode",{parentName:"td"},"n"),"-ary, ",(0,r.kt)("inlineCode",{parentName:"td"},"n > 1"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"?")))),(0,r.kt)("p",null,"To manage this circumstance we need something ",(0,r.kt)("em",{parentName:"p"},"more"),", in the next chapter we'll see another important abstraction in functional programming: ",(0,r.kt)("strong",{parentName:"p"},"applicative functors"),"."))}c.isMDXComponent=!0}}]);