"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[283],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(t),f=o,d=u["".concat(p,".").concat(f)]||u[f]||m[f]||i;return t?a.createElement(d,r(r({ref:n},c),{},{components:t})):a.createElement(d,r({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=f;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[u]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},9042:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(7462),o=(t(7294),t(3905));const i={},r="Pure and partial functions",l={unversionedId:"Pure and partial functions",id:"Pure and partial functions",title:"Pure and partial functions",description:"In the first chapter we've seen an informal definition of a pure function:",source:"@site/docs/6. Pure and partial functions.md",sourceDirName:".",slug:"/Pure and partial functions",permalink:"/functional-programming/Pure and partial functions",draft:!1,editUrl:"https://github.com/wwmmzz/functional-programming/blob/master/website/docs/6. Pure and partial functions.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Modeling composition through Monoids",permalink:"/functional-programming/Modeling composition through Monoids"},next:{title:"Algebraic Data Types",permalink:"/functional-programming/Algebraic Data Types"}},p={},s=[],c={toc:s},u="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"pure-and-partial-functions"},"Pure and partial functions"),(0,o.kt)("p",null,"In the first chapter we've seen an informal definition of a pure function:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A pure function is a procedure that given the same input always returns the same output and does not have any observable side effect.")),(0,o.kt)("p",null,"Such an informal statement could leave space for some doubts, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'what is a "side effect"?'),(0,o.kt)("li",{parentName:"ul"},'what does it means "observable"?'),(0,o.kt)("li",{parentName:"ul"},'what does it mean "same"?')),(0,o.kt)("p",null,"Let's see a formal definition of the concept of a function."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),". If ",(0,o.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Y")," are sets, then with ",(0,o.kt)("inlineCode",{parentName:"p"},"X \xd7 Y")," we indicate their ",(0,o.kt)("em",{parentName:"p"},"cartesian product"),", meaning the set"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"X \xd7 Y = { (x, y) | x \u2208 X, y \u2208 Y }\n")),(0,o.kt)("p",null,"The following ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/History_of_the_function_concept"},"definition")," was given a century ago:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Definition"),". A ","_","function: ",(0,o.kt)("inlineCode",{parentName:"p"},"f: X \u27f6 Y")," is a subset of ",(0,o.kt)("inlineCode",{parentName:"p"},"X \xd7 Y")," such as\nfor every ",(0,o.kt)("inlineCode",{parentName:"p"},"x \u2208 X")," there's exactly one ",(0,o.kt)("inlineCode",{parentName:"p"},"y \u2208 Y")," such that ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y) \u2208 f"),"."),(0,o.kt)("p",null,"The set ",(0,o.kt)("inlineCode",{parentName:"p"},"X")," is called the ",(0,o.kt)("em",{parentName:"p"},"domain")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Y")," is it's ",(0,o.kt)("em",{parentName:"p"},"codomain"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"double: Nat \u27f6 Nat")," is the subset of the cartesian product ",(0,o.kt)("inlineCode",{parentName:"p"},"Nat \xd7 Nat")," given by ",(0,o.kt)("inlineCode",{parentName:"p"},"{ (1, 2), (2, 4), (3, 6), ...}"),"."),(0,o.kt)("p",null,"In TypeScript we could define ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const f: Record<number, number> = {\n  1: 2,\n  2: 4,\n  3: 6\n  ...\n}\n")),(0,o.kt)("p",null,"The one in the example is called an ",(0,o.kt)("em",{parentName:"p"},"extensional")," definition of a function, meaning we enumerate one by one each of the elements of its domain and for each one of them we point the corresponding codomain element."),(0,o.kt)("p",null,"Naturally, when such a set is infinite this proves to be problematic. We can't list the entire domain and codomain of all functions."),(0,o.kt)("p",null,"We can get around this issue by introducing the one that is called ",(0,o.kt)("em",{parentName:"p"},"intensional")," definition, meaning that we express a condition that has to hold for every couple ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y) \u2208 f")," meaning ",(0,o.kt)("inlineCode",{parentName:"p"},"y = x * 2"),"."),(0,o.kt)("p",null,"This the familiar form in which we write the ",(0,o.kt)("inlineCode",{parentName:"p"},"double")," function and its definition in TypeScript:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const double = (x: number): number => x * 2\n")),(0,o.kt)("p",null,"The definition of a function as a subset of a cartesian product shows how in mathematics every function is pure: there is no action, no state mutation or elements being modified.\nIn functional programming the implementation of functions has to follow as much as possible this ideal model."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Quiz"),". Which of the following procedures are pure functions?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const coefficient1 = 2\nexport const f1 = (n: number) => n * coefficient1\n\n// ------------------------------------------------------\n\nlet coefficient2 = 2\nexport const f2 = (n: number) => n * coefficient2++\n\n// ------------------------------------------------------\n\nlet coefficient3 = 2\nexport const f3 = (n: number) => n * coefficient3\n\n// ------------------------------------------------------\n\nexport const f4 = (n: number) => {\n  const out = n * 2\n  console.log(out)\n  return out\n}\n\n// ------------------------------------------------------\n\ninterface User {\n  readonly id: number\n  readonly name: string\n}\n\nexport declare const f5: (id: number) => Promise<User>\n\n// ------------------------------------------------------\n\nimport * as fs from 'fs'\n\nexport const f6 = (path: string): string =>\n  fs.readFileSync(path, { encoding: 'utf8' })\n\n// ------------------------------------------------------\n\nexport const f7 = (\n  path: string,\n  callback: (err: Error | null, data: string) => void\n): void => fs.readFile(path, { encoding: 'utf8' }, callback)\n")),(0,o.kt)("p",null,"The fact that a function is pure does not imply automatically a ban on local mutability as long as it doesn't leaks out of its scope."),(0,o.kt)("center",null,(0,o.kt)("img",{src:"images/mutable-immutable.jpg",width:"400",alt:"ADT"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")," (Implementazion details of the ",(0,o.kt)("inlineCode",{parentName:"p"},"concatAll")," function for monoids)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid } from 'fp-ts/Monoid'\n\nconst concatAll = <A>(M: Monoid<A>) => (as: ReadonlyArray<A>): A => {\n  let out: A = M.empty // <= local mutability\n  for (const a of as) {\n    out = M.concat(out, a)\n  }\n  return out\n}\n")),(0,o.kt)("p",null,"The ultimate goal is to guarantee: ",(0,o.kt)("strong",{parentName:"p"},"referential transparency"),"."),(0,o.kt)("p",null,"The contract we sign with a user of our APIs is defined by the APIs signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"declare const concatAll: <A>(M: Monoid<A>) => (as: ReadonlyArray<A>) => A\n")),(0,o.kt)("p",null,"and by the promise of respecting referential transparency. The technical details of how the function is implemented are not relevant, thus there is maximum freedom implementation-wise."),(0,o.kt)("p",null,'Thus, how do we define a "side effect"? Simply by negating referential transparency:'),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'An expression contains "side effects" if it doesn\'t benefit from referential transparency')),(0,o.kt)("p",null,"Not only functions are a perfect example of one of the two pillars of functional programming, referential transparency, but they're also examples of the second pillar: ",(0,o.kt)("strong",{parentName:"p"},"composition"),"."),(0,o.kt)("p",null,"Functions compose:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Definition"),". Given ",(0,o.kt)("inlineCode",{parentName:"p"},"f: Y \u27f6 Z")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"g: X \u27f6 Y")," two functions, then the function ",(0,o.kt)("inlineCode",{parentName:"p"},"h: X \u27f6 Z")," defined by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"h(x) = f(g(x))\n")),(0,o.kt)("p",null,"is called ",(0,o.kt)("em",{parentName:"p"},"composition")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," and is written ",(0,o.kt)("inlineCode",{parentName:"p"},"h = f \u2218 g")),(0,o.kt)("p",null,"Please note that in order for ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," to combine, the domain of ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," has to be included in the codomain of ",(0,o.kt)("inlineCode",{parentName:"p"},"g"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Definition"),". A function is said to be ",(0,o.kt)("em",{parentName:"p"},"partial")," if it is not defined for each value of its domain."),(0,o.kt)("p",null,"Vice versa, a function defined for all values of its domain is said to be ",(0,o.kt)("em",{parentName:"p"},"total")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"f(x) = 1 / x\n")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"f: number \u27f6 number")," is not defined for ",(0,o.kt)("inlineCode",{parentName:"p"},"x = 0"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Get the first element of a `ReadonlyArray`\ndeclare const head: <A>(as: ReadonlyArray<A>) => A\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Quiz"),". Why is the ",(0,o.kt)("inlineCode",{parentName:"p"},"head")," function partial?"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Quiz"),". Is ",(0,o.kt)("inlineCode",{parentName:"p"},"JSON.parse")," a total function?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"parse: (text: string, reviver?: (this: any, key: string, value: any) => any) =>\n  any\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Quiz"),". Is ",(0,o.kt)("inlineCode",{parentName:"p"},"JSON.stringify")," a total function?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"stringify: (\n  value: any,\n  replacer?: (this: any, key: string, value: any) => any,\n  space?: string | number\n) => string\n")),(0,o.kt)("p",null,"In functional programming there is a tendency to only define ",(0,o.kt)("strong",{parentName:"p"},"pure and total functions"),'. From now on with the term function we\'ll be specifically referring to "pure and total function". So what do we do when we have a partial function in our applications?'),(0,o.kt)("p",null,"A partial function ",(0,o.kt)("inlineCode",{parentName:"p"},"f: X \u27f6 Y"),' can always be "brought back" to a total one by adding a special value, let\'s call it ',(0,o.kt)("inlineCode",{parentName:"p"},"None"),", to the codomain and by assigning it to the output of ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," for every value of ",(0,o.kt)("inlineCode",{parentName:"p"},"X")," where the function is not defined."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"f': X \u27f6 Y \u222a None\n")),(0,o.kt)("p",null,"Let's call it ",(0,o.kt)("inlineCode",{parentName:"p"},"Option(Y) = Y \u222a None"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"f': X \u27f6 Option(Y)\n")),(0,o.kt)("p",null,"In functional programming the tendency is to define only pure and and total functions."),(0,o.kt)("p",null,"Is it possible to define ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," in TypeScript? In the following chapters we'll see how to do it."))}m.isMDXComponent=!0}}]);