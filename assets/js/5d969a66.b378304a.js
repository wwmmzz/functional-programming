"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[378],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=s(n),c=r,k=u["".concat(p,".").concat(c)]||u[c]||d[c]||o;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=c;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[u]="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9067:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const o={},l="Algebraic Data Types",i={unversionedId:"Algebraic Data Types",id:"Algebraic Data Types",title:"Algebraic Data Types",description:"A good first step when writing an application or feature is to define it's domain model. TypeScript offers many tools that help accomplishing this task. Algebraic Data Types (in short, ADTs) are one of these tools.",source:"@site/docs/7. Algebraic Data Types.md",sourceDirName:".",slug:"/Algebraic Data Types",permalink:"/functional-programming/Algebraic Data Types",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pure and partial functions",permalink:"/functional-programming/Pure and partial functions"},next:{title:"Category theory",permalink:"/functional-programming/Category theory"}},p={},s=[{value:"What is an ADT?",id:"what-is-an-adt",level:2},{value:"Product types",id:"product-types",level:2},{value:"Why &quot;product&quot; types?",id:"why-product-types",level:3},{value:"When can I use a product type?",id:"when-can-i-use-a-product-type",level:3},{value:"Sum types",id:"sum-types",level:2},{value:"Constructors",id:"constructors",level:3},{value:"Pattern matching",id:"pattern-matching",level:3},{value:"Why &quot;sum&quot; types?",id:"why-sum-types",level:3},{value:"When should I use a sum type?",id:"when-should-i-use-a-sum-type",level:3},{value:"Functional error handling",id:"functional-error-handling",level:2},{value:"The <code>Option</code> type",id:"the-option-type",level:3},{value:"An <code>Eq</code> instance",id:"an-eq-instance",level:3},{value:"<code>Semigroup</code> and <code>Monoid</code> instances",id:"semigroup-and-monoid-instances",level:3},{value:"The <code>Either</code> type",id:"the-either-type",level:3}],m={toc:s},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"algebraic-data-types"},"Algebraic Data Types"),(0,r.kt)("p",null,"A good first step when writing an application or feature is to define it's domain model. TypeScript offers many tools that help accomplishing this task. ",(0,r.kt)("strong",{parentName:"p"},"Algebraic Data Types")," (in short, ADTs) are one of these tools."),(0,r.kt)("h2",{id:"what-is-an-adt"},"What is an ADT?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In computer programming, especially functional programming and type theory, an algebraic data type is a kind of composite type, i.e., ",(0,r.kt)("strong",{parentName:"p"},"a type formed by combining other types"),".")),(0,r.kt)("p",null,"Two common families of algebraic data types are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"product types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"sum types"))),(0,r.kt)("center",null,(0,r.kt)("img",{src:"images/adt.png",width:"400",alt:"ADT"})),(0,r.kt)("p",null,"Let's begin with the more familiar ones: product types."),(0,r.kt)("h2",{id:"product-types"},"Product types"),(0,r.kt)("p",null,"A product type is a collection of types T",(0,r.kt)("sub",null,"i")," indexed by a set ",(0,r.kt)("inlineCode",{parentName:"p"},"I"),"."),(0,r.kt)("p",null,"Two members of this family are ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"-tuples, where ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," is an interval of natural numbers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Tuple1 = [string] // I = [0]\ntype Tuple2 = [string, number] // I = [0, 1]\ntype Tuple3 = [string, number, boolean] // I = [0, 1, 2]\n\n// Accessing by index\ntype Fst = Tuple2[0] // string\ntype Snd = Tuple2[1] // number\n")),(0,r.kt)("p",null,"and structs, where ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," is a set of labels:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// I = {\"name\", \"age\"}\ninterface Person {\n  name: string\n  age: number\n}\n\n// Accessing by label\ntype Name = Person['name'] // string\ntype Age = Person['age'] // number\n")),(0,r.kt)("p",null,"Product types can be ",(0,r.kt)("strong",{parentName:"p"},"polimorphic"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"//                \u2193 type parameter\ntype HttpResponse<A> = {\n  readonly code: number\n  readonly body: A\n}\n")),(0,r.kt)("h3",{id:"why-product-types"},'Why "product" types?'),(0,r.kt)("p",null,"If we label with ",(0,r.kt)("inlineCode",{parentName:"p"},"C(A)")," the number of elements of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," (also called in mathematics, ",(0,r.kt)("strong",{parentName:"p"},"cardinality"),"), then the following equation hold true:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"C([A, B]) = C(A) * C(B)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"the cardinality of a product is the product of the cardinalities")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," type has cardinality ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," because it has only one member: ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),": What is the cardinality of the ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Hour = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12\ntype Period = 'AM' | 'PM'\ntype Clock = [Hour, Period]\n")),(0,r.kt)("p",null,"Type ",(0,r.kt)("inlineCode",{parentName:"p"},"Hour")," has 12 members.\nType ",(0,r.kt)("inlineCode",{parentName:"p"},"Period")," has 2 members.\nThus type ",(0,r.kt)("inlineCode",{parentName:"p"},"Clock")," has ",(0,r.kt)("inlineCode",{parentName:"p"},"12 * 2 = 24")," elements."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),": What is the cardinality of the following ",(0,r.kt)("inlineCode",{parentName:"p"},"Clock")," type?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// same as before\ntype Hour = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12\n// same as before\ntype Period = 'AM' | 'PM'\n\n// different encoding, no longer a Tuple\ntype Clock = {\n  readonly hour: Hour\n  readonly period: Period\n}\n")),(0,r.kt)("h3",{id:"when-can-i-use-a-product-type"},"When can I use a product type?"),(0,r.kt)("p",null,"Each time it's components are ",(0,r.kt)("strong",{parentName:"p"},"independent"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Clock = [Hour, Period]\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"Hour")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Period")," are independent: the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"Hour")," does not change the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"Period"),". Every legal pair of ",(0,r.kt)("inlineCode",{parentName:"p"},"[Hour, Period]"),' makes "sense" and is legal.'),(0,r.kt)("h2",{id:"sum-types"},"Sum types"),(0,r.kt)("p",null,'A sum type is a a data type that can hold a value of different (but limited) types. Only one of these types can be used in a single instance and there is generally a "tag" value differentiating those types.'),(0,r.kt)("p",null,"In TypeScript's official docs they are called ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html"},"discriminated union"),"."),(0,r.kt)("p",null,"It is important to note that the members of the union have to be ",(0,r.kt)("strong",{parentName:"p"},"disjoint"),", there can't be values that belong to more than one member."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"The type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type StringsOrNumbers = ReadonlyArray<string> | ReadonlyArray<number>\n\ndeclare const sn: StringsOrNumbers\n\nsn.map() // error: This expression is not callable.\n")),(0,r.kt)("p",null,"is not a disjoint union because the value ",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),", the empty array, belongs to both members."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Is the following union disjoint?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Member1 = { readonly a: string }\ntype Member2 = { readonly b: number }\ntype MyUnion = Member1 | Member2\n")),(0,r.kt)("p",null,"Disjoint unions are recurring in functional programming."),(0,r.kt)("p",null,"Fortunately ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeScript")," has a way to guarantee that a union is disjoint: add a specific field that works as a ",(0,r.kt)("strong",{parentName:"p"},"tag"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": Disjoint unions, sum types and tagged unions are used interchangeably to indicate the same thing."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (redux actions)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Action")," sum type models a portion of the operation that the user can take i a ",(0,r.kt)("a",{parentName:"p",href:"https://todomvc.com/"},"todo app"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Action =\n  | {\n      type: 'ADD_TODO'\n      text: string\n    }\n  | {\n      type: 'UPDATE_TODO'\n      id: number\n      text: string\n      completed: boolean\n    }\n  | {\n      type: 'DELETE_TODO'\n      id: number\n    }\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," tag makes sure every member of the union is disjointed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),'. The name of the field that acts as a tag is chosen by the developer. It doesn\'t have to be "type". In ',(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts")," the convention is to use a ",(0,r.kt)("inlineCode",{parentName:"p"},"_tag")," field."),(0,r.kt)("p",null,"Now that we've seen few examples we can define more explicitly what algebraic data types are:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In general, an algebraic data type specifies a sum of one or more alternatives, where each alternative is a product of zero or more fields.")),(0,r.kt)("p",null,"Sum types can be ",(0,r.kt)("strong",{parentName:"p"},"polymorphic")," and ",(0,r.kt)("strong",{parentName:"p"},"recursive"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (linked list)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"//               \u2193 type parameter\nexport type List<A> =\n  | { readonly _tag: 'Nil' }\n  | { readonly _tag: 'Cons'; readonly head: A; readonly tail: List<A> }\n//                                                              \u2191 recursion\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz")," (TypeScript). Which of the following data types is a product or a sum type?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ReadonlyArray<A>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Record<string, A>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Record<'k1' | 'k2', A>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ReadonlyMap<string, A>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ReadonlyMap<'k1' | 'k2', A>"))),(0,r.kt)("h3",{id:"constructors"},"Constructors"),(0,r.kt)("p",null,"A sum type with ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," elements needs at least ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," ",(0,r.kt)("strong",{parentName:"p"},"constructors"),", one for each member:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (redux action creators)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export type Action =\n  | {\n      readonly type: 'ADD_TODO'\n      readonly text: string\n    }\n  | {\n      readonly type: 'UPDATE_TODO'\n      readonly id: number\n      readonly text: string\n      readonly completed: boolean\n    }\n  | {\n      readonly type: 'DELETE_TODO'\n      readonly id: number\n    }\n\nexport const add = (text: string): Action => ({\n  type: 'ADD_TODO',\n  text\n})\n\nexport const update = (\n  id: number,\n  text: string,\n  completed: boolean\n): Action => ({\n  type: 'UPDATE_TODO',\n  id,\n  text,\n  completed\n})\n\nexport const del = (id: number): Action => ({\n  type: 'DELETE_TODO',\n  id\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (TypeScript, linked lists)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export type List<A> =\n  | { readonly _tag: 'Nil' }\n  | { readonly _tag: 'Cons'; readonly head: A; readonly tail: List<A> }\n\n// a nullary constructor can be implemented as a constant\nexport const nil: List<never> = { _tag: 'Nil' }\n\nexport const cons = <A>(head: A, tail: List<A>): List<A> => ({\n  _tag: 'Cons',\n  head,\n  tail\n})\n\n// equivalent to an array containing [1, 2, 3]\nconst myList = cons(1, cons(2, cons(3, nil)))\n")),(0,r.kt)("h3",{id:"pattern-matching"},"Pattern matching"),(0,r.kt)("p",null,"JavaScript doesn't support ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-pattern-matching"},"pattern matching")," (neither does TypeScript) but we can simulate it with a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," function."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (TypeScript, linked lists)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface Nil {\n  readonly _tag: 'Nil'\n}\n\ninterface Cons<A> {\n  readonly _tag: 'Cons'\n  readonly head: A\n  readonly tail: List<A>\n}\n\nexport type List<A> = Nil | Cons<A>\n\nexport const match = <R, A>(\n  onNil: () => R,\n  onCons: (head: A, tail: List<A>) => R\n) => (fa: List<A>): R => {\n  switch (fa._tag) {\n    case 'Nil':\n      return onNil()\n    case 'Cons':\n      return onCons(fa.head, fa.tail)\n  }\n}\n\n// returns `true` if the list is empty\nexport const isEmpty = match(\n  () => true,\n  () => false\n)\n\n// returns the first element of the list or `undefined`\nexport const head = match(\n  () => undefined,\n  (head, _tail) => head\n)\n\n// returns the length of the list, recursively\nexport const length: <A>(fa: List<A>) => number = match(\n  () => 0,\n  (_, tail) => 1 + length(tail)\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Why's the ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," API sub optimal?"),(0,r.kt)("p",null,"-> See the ",(0,r.kt)("a",{parentName:"p",href:"/functional-programming/quiz-answers/pattern-matching"},"answer here")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),". TypeScript offers a great feature for sum types: ",(0,r.kt)("strong",{parentName:"p"},"exhaustive check"),". The type checker can ",(0,r.kt)("em",{parentName:"p"},"check"),", no pun intended, whether all the possible cases are handled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," defined in the body of the function."),(0,r.kt)("h3",{id:"why-sum-types"},'Why "sum" types?'),(0,r.kt)("p",null,"Because the following identity holds true:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"C(A | B) = C(A) + C(B)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The sum of the cardinality is the sum of the cardinalities")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," type)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface None {\n  readonly _tag: 'None'\n}\n\ninterface Some<A> {\n  readonly _tag: 'Some'\n  readonly value: A\n}\n\ntype Option<A> = None | Some<A>\n")),(0,r.kt)("p",null,"From the general formula ",(0,r.kt)("inlineCode",{parentName:"p"},"C(Option<A>) = 1 + C(A)")," we can derive the cardinality of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<boolean>")," type: ",(0,r.kt)("inlineCode",{parentName:"p"},"1 + 2 = 3")," members."),(0,r.kt)("h3",{id:"when-should-i-use-a-sum-type"},"When should I use a sum type?"),(0,r.kt)("p",null,"When the components would be ",(0,r.kt)("strong",{parentName:"p"},"dependent")," if implemented with a product type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"React")," props)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as React from 'react'\n\ninterface Props {\n  readonly editable: boolean\n  readonly onChange?: (text: string) => void\n}\n\nclass Textbox extends React.Component<Props> {\n  render() {\n    if (this.props.editable) {\n      // error: Cannot invoke an object which is possibly 'undefined' :(\n      this.props.onChange('a')\n    }\n    return <div />\n  }\n}\n")),(0,r.kt)("p",null,"The problem here is that ",(0,r.kt)("inlineCode",{parentName:"p"},"Props")," is modeled like a product, but ",(0,r.kt)("inlineCode",{parentName:"p"},"onChange")," ",(0,r.kt)("strong",{parentName:"p"},"depends")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"editable"),"."),(0,r.kt)("p",null,"A sum type fits the use case better:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as React from 'react'\n\ntype Props =\n  | {\n      readonly type: 'READONLY'\n    }\n  | {\n      readonly type: 'EDITABLE'\n      readonly onChange: (text: string) => void\n    }\n\nclass Textbox extends React.Component<Props> {\n  render() {\n    switch (this.props.type) {\n      case 'EDITABLE':\n        this.props.onChange('a') // :)\n    }\n    return <div />\n  }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (node callbacks)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function readFile(\n  path: string,\n  //         \u2193 ---------- \u2193 CallbackArgs\n  callback: (err?: Error, data?: string) => void\n): void\n")),(0,r.kt)("p",null,"The result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"readFile")," operation is modeled like a product type (to be more precise, as a tuple) which is later on passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"callback")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type CallbackArgs = [Error | undefined, string | undefined]\n")),(0,r.kt)("p",null,"the callback components though are ",(0,r.kt)("strong",{parentName:"p"},"dependent"),": we either get an ",(0,r.kt)("inlineCode",{parentName:"p"},"Error")," ",(0,r.kt)("strong",{parentName:"p"},"or")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"err"),(0,r.kt)("th",{parentName:"tr",align:null},"data"),(0,r.kt)("th",{parentName:"tr",align:null},"legal?"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Error")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2713")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2713")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Error")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2718")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2718")))),(0,r.kt)("p",null,"This API is clearly not modeled on the following premise:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Make impossible state unrepresentable")),(0,r.kt)("p",null,"A sum type would've been a better choice, but which sum type?\nWe'll see how to handle errors in a functional way."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Recently API's based on callbacks have been largely replaced by their ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise")," equivalents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function readFile(path: string): Promise<string>\n")),(0,r.kt)("p",null,"Can you find some cons of the Promise solution when using static typing like in TypeScript?"),(0,r.kt)("h2",{id:"functional-error-handling"},"Functional error handling"),(0,r.kt)("p",null,"Let's see how to handle errors in a functional way."),(0,r.kt)("p",null,"A function that throws exceptions is an example of a partial function."),(0,r.kt)("p",null,"In the previous chapters we have seen that every partial function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," can always be brought back to a total one ",(0,r.kt)("inlineCode",{parentName:"p"},"f'"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"f': X \u27f6 Option(Y)\n")),(0,r.kt)("p",null,"Now that we know a bit more about sum types in TypeScript we can define the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," without much issues."),(0,r.kt)("h3",{id:"the-option-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option")," type"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," represents the effect of a computation which may fail (case ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),") or return a type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," (case ",(0,r.kt)("inlineCode",{parentName:"p"},"Some<A>"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// represents a failure\ninterface None {\n  readonly _tag: 'None'\n}\n\n// represents a success\ninterface Some<A> {\n  readonly _tag: 'Some'\n  readonly value: A\n}\n\ntype Option<A> = None | Some<A>\n")),(0,r.kt)("p",null,"Constructors and pattern matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const none: Option<never> = { _tag: 'None' }\n\nconst some = <A>(value: A): Option<A> => ({ _tag: 'Some', value })\n\nconst match = <R, A>(onNone: () => R, onSome: (a: A) => R) => (\n  fa: Option<A>\n): R => {\n  switch (fa._tag) {\n    case 'None':\n      return onNone()\n    case 'Some':\n      return onSome(fa.value)\n  }\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," type can be used to avoid throwing exceptions or representing the optional values, thus we can move from:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"//                        this is a lie \u2193\nconst head = <A>(as: ReadonlyArray<A>): A => {\n  if (as.length === 0) {\n    throw new Error('Empty array')\n  }\n  return as[0]\n}\n\nlet s: string\ntry {\n  s = String(head([]))\n} catch (e) {\n  s = e.message\n}\n")),(0,r.kt)("p",null,"where the type system is ignorant about the possibility of failure, to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\n\n//                                      \u2193 the type system \"knows\" that this computation may fail\nconst head = <A>(as: ReadonlyArray<A>): Option<A> =>\n  as.length === 0 ? none : some(as[0])\n\ndeclare const numbers: ReadonlyArray<number>\n\nconst result = pipe(\n  head(numbers),\n  match(\n    () => 'Empty array',\n    (n) => String(n)\n  )\n)\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("strong",{parentName:"p"},"the possibility of an error is encoded in the type system"),"."),(0,r.kt)("p",null,"If we attempt to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," property of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," without checking in which case we are, the type system will warn us about the possibility of getting an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const numbers: ReadonlyArray<number>\n\nconst result = head(numbers)\nresult.value // type checker error: Property 'value' does not exist on type 'Option<number>'\n")),(0,r.kt)("p",null,"The only way to access the value contained in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," is to handle also the failure case using the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"pipe(result, match(\n  () => ...handle error...\n  (n) => ...go on with my business logic...\n))\n")),(0,r.kt)("p",null,"Is it possible to define instances for the abstractions we've seen in the chapters before? Let's begin with ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq"),"."),(0,r.kt)("h3",{id:"an-eq-instance"},"An ",(0,r.kt)("inlineCode",{parentName:"h3"},"Eq")," instance"),(0,r.kt)("p",null,"Suppose we have two values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<string>")," and that we want to compare them to check if their equal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport { match, Option } from 'fp-ts/Option'\n\ndeclare const o1: Option<string>\ndeclare const o2: Option<string>\n\nconst result: boolean = pipe(\n  o1,\n  match(\n    // onNone o1\n    () =>\n      pipe(\n        o2,\n        match(\n          // onNone o2\n          () => true,\n          // onSome o2\n          () => false\n        )\n      ),\n    // onSome o1\n    (s1) =>\n      pipe(\n        o2,\n        match(\n          // onNone o2\n          () => false,\n          // onSome o2\n          (s2) => s1 === s2 // <= qui uso l'uguaglianza tra stringhe\n        )\n      )\n  )\n)\n")),(0,r.kt)("p",null,"What if we had two values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<number>"),"? It would be pretty annoying to write the same code we just wrote above, the only difference afterall would be how we compare the two values contained in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),"."),(0,r.kt)("p",null,"Thus we can generalize the necessary code by requiring the user to provide an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and then derive an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<A>"),"."),(0,r.kt)("p",null,"In other words we can define a ",(0,r.kt)("strong",{parentName:"p"},"combinator")," ",(0,r.kt)("inlineCode",{parentName:"p"},"getEq"),": given an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq<A>")," this combinator will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq<Option<A>>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/Eq'\nimport { pipe } from 'fp-ts/function'\nimport { match, Option, none, some } from 'fp-ts/Option'\n\nexport const getEq = <A>(E: Eq<A>): Eq<Option<A>> => ({\n  equals: (first, second) =>\n    pipe(\n      first,\n      match(\n        () =>\n          pipe(\n            second,\n            match(\n              () => true,\n              () => false\n            )\n          ),\n        (a1) =>\n          pipe(\n            second,\n            match(\n              () => false,\n              (a2) => E.equals(a1, a2) // <= here I use the `A` equality\n            )\n          )\n      )\n    )\n})\n\nimport * as S from 'fp-ts/string'\n\nconst EqOptionString = getEq(S.Eq)\n\nconsole.log(EqOptionString.equals(none, none)) // => true\nconsole.log(EqOptionString.equals(none, some('b'))) // => false\nconsole.log(EqOptionString.equals(some('a'), none)) // => false\nconsole.log(EqOptionString.equals(some('a'), some('b'))) // => false\nconsole.log(EqOptionString.equals(some('a'), some('a'))) // => true\n")),(0,r.kt)("p",null,"The best thing about being able to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for a type ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<A>")," is being able to leverage all of the combiners we've seen previously for ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<readonly [string, number]>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { tuple } from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\nimport { getEq, Option, some } from 'fp-ts/Option'\nimport * as S from 'fp-ts/string'\n\ntype MyTuple = readonly [string, number]\n\nconst EqMyTuple = tuple<MyTuple>(S.Eq, N.Eq)\n\nconst EqOptionMyTuple = getEq(EqMyTuple)\n\nconst o1: Option<MyTuple> = some(['a', 1])\nconst o2: Option<MyTuple> = some(['a', 2])\nconst o3: Option<MyTuple> = some(['b', 1])\n\nconsole.log(EqOptionMyTuple.equals(o1, o1)) // => true\nconsole.log(EqOptionMyTuple.equals(o1, o2)) // => false\nconsole.log(EqOptionMyTuple.equals(o1, o3)) // => false\n")),(0,r.kt)("p",null,"If we slightly modify the imports in the following snippet we can obtain a similar result for ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as N from 'fp-ts/number'\nimport { getOrd, Option, some } from 'fp-ts/Option'\nimport { tuple } from 'fp-ts/Ord'\nimport * as S from 'fp-ts/string'\n\ntype MyTuple = readonly [string, number]\n\nconst OrdMyTuple = tuple<MyTuple>(S.Ord, N.Ord)\n\nconst OrdOptionMyTuple = getOrd(OrdMyTuple)\n\nconst o1: Option<MyTuple> = some(['a', 1])\nconst o2: Option<MyTuple> = some(['a', 2])\nconst o3: Option<MyTuple> = some(['b', 1])\n\nconsole.log(OrdOptionMyTuple.compare(o1, o1)) // => 0\nconsole.log(OrdOptionMyTuple.compare(o1, o2)) // => -1\nconsole.log(OrdOptionMyTuple.compare(o1, o3)) // => -1\n")),(0,r.kt)("h3",{id:"semigroup-and-monoid-instances"},(0,r.kt)("inlineCode",{parentName:"h3"},"Semigroup")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"Monoid")," instances"),(0,r.kt)("p",null,'Now, let\'s suppose we want to "merge" two different ',(0,r.kt)("inlineCode",{parentName:"p"},"Option<A>"),"s,: there are four different cases:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"x"),(0,r.kt)("th",{parentName:"tr",align:null},"y"),(0,r.kt)("th",{parentName:"tr",align:null},"concat(x, y)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(b)"),(0,r.kt)("td",{parentName:"tr",align:null},"?")))),(0,r.kt)("p",null,'There\'s an issue in the last case, we need a recipe to "merge" two different ',(0,r.kt)("inlineCode",{parentName:"p"},"A"),"s."),(0,r.kt)("p",null,"If only we had such a recipe..Isn't that the job our old good friends ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup"),"s!?"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"x"),(0,r.kt)("th",{parentName:"tr",align:null},"y"),(0,r.kt)("th",{parentName:"tr",align:null},"concat(x, y)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(S.concat(a1, a2))")))),(0,r.kt)("p",null,"All we need to do is to require the user to provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and then derive a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<A>"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// the implementation is left as an exercise for the reader\ndeclare const getApplySemigroup: <A>(S: Semigroup<A>) => Semigroup<Option<A>>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Is it possible to add a neutral element to the previous semigroup to make it a monoid?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// the implementation is left as an exercise for the reader\ndeclare const getApplicativeMonoid: <A>(M: Monoid<A>) => Monoid<Option<A>>\n")),(0,r.kt)("p",null,"It is possible to define a monoid instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<A>")," that behaves like that:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"x"),(0,r.kt)("th",{parentName:"tr",align:null},"y"),(0,r.kt)("th",{parentName:"tr",align:null},"concat(x, y)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(S.concat(a1, a2))")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// the implementation is left as an exercise for the reader\ndeclare const getMonoid: <A>(S: Semigroup<A>) => Monoid<Option<A>>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". What is the ",(0,r.kt)("inlineCode",{parentName:"p"},"empty")," member for the monoid?"),(0,r.kt)("p",null,"-> See the ",(0,r.kt)("a",{parentName:"p",href:"/functional-programming/quiz-answers/option-semigroup-monoid-second"},"answer here")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"getMonoid")," we can derive another two useful monoids:"),(0,r.kt)("p",null,"(Monoid returning the left-most non-",(0,r.kt)("inlineCode",{parentName:"p"},"None")," value)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"x"),(0,r.kt)("th",{parentName:"tr",align:null},"y"),(0,r.kt)("th",{parentName:"tr",align:null},"concat(x, y)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid } from 'fp-ts/Monoid'\nimport { getMonoid, Option } from 'fp-ts/Option'\nimport { first } from 'fp-ts/Semigroup'\n\nexport const getFirstMonoid = <A = never>(): Monoid<Option<A>> =>\n  getMonoid(first())\n")),(0,r.kt)("p",null,"and its dual:"),(0,r.kt)("p",null,"(Monoid returning the right-most non-",(0,r.kt)("inlineCode",{parentName:"p"},"None")," value)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"x"),(0,r.kt)("th",{parentName:"tr",align:null},"y"),(0,r.kt)("th",{parentName:"tr",align:null},"concat(x, y)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(a1)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"some(a2)")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid } from 'fp-ts/Monoid'\nimport { getMonoid, Option } from 'fp-ts/Option'\nimport { last } from 'fp-ts/Semigroup'\n\nexport const getLastMonoid = <A = never>(): Monoid<Option<A>> =>\n  getMonoid(last())\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getLastMonoid")," can be useful to manage optional values. Let's seen an example where we want to derive user settings for a text editor, in this case VSCode."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid, struct } from 'fp-ts/Monoid'\nimport { getMonoid, none, Option, some } from 'fp-ts/Option'\nimport { last } from 'fp-ts/Semigroup'\n\n/** VSCode settings */\ninterface Settings {\n  /** Controls the font family */\n  readonly fontFamily: Option<string>\n  /** Controls the font size in pixels */\n  readonly fontSize: Option<number>\n  /** Limit the width of the minimap to render at most a certain number of columns. */\n  readonly maxColumn: Option<number>\n}\n\nconst monoidSettings: Monoid<Settings> = struct({\n  fontFamily: getMonoid(last()),\n  fontSize: getMonoid(last()),\n  maxColumn: getMonoid(last())\n})\n\nconst workspaceSettings: Settings = {\n  fontFamily: some('Courier'),\n  fontSize: none,\n  maxColumn: some(80)\n}\n\nconst userSettings: Settings = {\n  fontFamily: some('Fira Code'),\n  fontSize: some(12),\n  maxColumn: none\n}\n\n/** userSettings overrides workspaceSettings */\nconsole.log(monoidSettings.concat(workspaceSettings, userSettings))\n/*\n{ fontFamily: some(\"Fira Code\"),\n  fontSize: some(12),\n  maxColumn: some(80) }\n*/\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Suppose VSCode cannot manage more than ",(0,r.kt)("inlineCode",{parentName:"p"},"80")," columns per row, how could we modify the definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"monoidSettings")," to take that into account?"),(0,r.kt)("h3",{id:"the-either-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"Either")," type"),(0,r.kt)("p",null,"We have seen how the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," data type can be used to handle partial functions, which often represent computations than can fail or throw exceptions."),(0,r.kt)("p",null,"This data type might be limiting in some use cases tho. While in the case of success we get ",(0,r.kt)("inlineCode",{parentName:"p"},"Some<A>")," which contains information of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", the other member, ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," does not carry any data. We know it failed, but we don't know the reason."),(0,r.kt)("p",null,"In order to fix this we simply need to another data type to represent failure, we'll call it ",(0,r.kt)("inlineCode",{parentName:"p"},"Left<E>"),". We'll also replace the ",(0,r.kt)("inlineCode",{parentName:"p"},"Some<A>")," type with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Right<A>"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// represents a failure\ninterface Left<E> {\n  readonly _tag: 'Left'\n  readonly left: E\n}\n\n// represents a success\ninterface Right<A> {\n  readonly _tag: 'Right'\n  readonly right: A\n}\n\ntype Either<E, A> = Left<E> | Right<A>\n")),(0,r.kt)("p",null,"Constructors and pattern matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const left = <E, A>(left: E): Either<E, A> => ({ _tag: 'Left', left })\n\nconst right = <A, E>(right: A): Either<E, A> => ({ _tag: 'Right', right })\n\nconst match = <E, R, A>(onLeft: (left: E) => R, onRight: (right: A) => R) => (\n  fa: Either<E, A>\n): R => {\n  switch (fa._tag) {\n    case 'Left':\n      return onLeft(fa.left)\n    case 'Right':\n      return onRight(fa.right)\n  }\n}\n")),(0,r.kt)("p",null,"Let's get back to the previous callback example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function readFile(\n  path: string,\n  callback: (err?: Error, data?: string) => void\n): void\n\nreadFile('./myfile', (err, data) => {\n  let message: string\n  if (err !== undefined) {\n    message = `Error: ${err.message}`\n  } else if (data !== undefined) {\n    message = `Data: ${data.trim()}`\n  } else {\n    // should never happen\n    message = 'The impossible happened'\n  }\n  console.log(message)\n})\n")),(0,r.kt)("p",null,"we can change it's signature to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function readFile(\n  path: string,\n  callback: (result: Either<Error, string>) => void\n): void\n")),(0,r.kt)("p",null,"and consume the API in such way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"readFile('./myfile', (e) =>\n  pipe(\n    e,\n    match(\n      (err) => `Error: ${err.message}`,\n      (data) => `Data: ${data.trim()}`\n    ),\n    console.log\n  )\n)\n")))}d.isMDXComponent=!0}}]);