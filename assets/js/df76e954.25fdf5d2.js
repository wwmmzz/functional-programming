"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(n),d=a,g=c["".concat(p,".").concat(d)]||c[d]||u[d]||o;return n?i.createElement(g,r(r({ref:t},m),{},{components:n})):i.createElement(g,r({ref:t},m))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2959:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const o={},r="Category theory",l={unversionedId:"Category theory",id:"Category theory",title:"Category theory",description:"We have seen how a founding pillar of functional programming is composition.",source:"@site/docs/8. Category theory.md",sourceDirName:".",slug:"/Category theory",permalink:"/functional-programming/Category theory",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/8. Category theory.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Algebraic Data Types",permalink:"/functional-programming/Algebraic Data Types"},next:{title:"Functors",permalink:"/functional-programming/Functors"}},p={},s=[{value:"Definition",id:"definition",level:2},{value:"Part I (Constituents)",id:"part-i-constituents",level:3},{value:"Part II (Composition)",id:"part-ii-composition",level:3},{value:"Modeling programming languages with categories",id:"modeling-programming-languages-with-categories",level:2},{value:"A category for TypeScript",id:"a-category-for-typescript",level:2},{value:"Composition&#39;s core problem",id:"compositions-core-problem",level:2}],m={toc:s},c="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"category-theory"},"Category theory"),(0,a.kt)("p",null,"We have seen how a founding pillar of functional programming is ",(0,a.kt)("strong",{parentName:"p"},"composition"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"And how do we solve problems? We decompose bigger problems into smaller problems. If the smaller problems are still too big, we decompose them further, and so on. Finally, we write code that solves all the small problems. And then comes the essence of programming: we compose those pieces of code to create solutions to larger problems. Decomposition wouldn't make sense if we weren't able to put the pieces back together. - Bartosz Milewski")),(0,a.kt)("p",null,"But what does it means exactly? How can we state whether two things ",(0,a.kt)("em",{parentName:"p"},"compose"),"? And how can we say if two things compose ",(0,a.kt)("em",{parentName:"p"},"well"),"?"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Entities are composable if we can easily and generally combine their behaviours in some way without having to modify the entities being combined. I think of composability as being the key ingredient necessary for achieving reuse, and for achieving a combinatorial expansion of what is succinctly expressible in a programming model. - Paul Chiusano")),(0,a.kt)("p",null,"We've briefly mentioned how a program written in functional styles tends to resemble a pipeline:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const program = pipe(\n  input,\n  f1, // pure function\n  f2, // pure function\n  f3, // pure function\n  ...\n)\n")),(0,a.kt)("p",null,"But how simple it is to code in such a style? Let's try:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as RA from 'fp-ts/ReadonlyArray'\n\nconst double = (n: number): number => n * 2\n\n/**\n * Given a ReadonlyArray<number> the program doubles the first element and returns it\n */\nconst program = (input: ReadonlyArray<number>): number =>\n  pipe(\n    input,\n    RA.head, // compilation error! Type 'Option<number>' is not assignable to type 'number'\n    double\n  )\n")),(0,a.kt)("p",null,"Why do I get a compilation error? Because ",(0,a.kt)("inlineCode",{parentName:"p"},"head")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"double")," do not compose."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"head: (as: ReadonlyArray<number>) => Option<number>\ndouble: (n: number) => number\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"head"),"'s codomain is not included in ",(0,a.kt)("inlineCode",{parentName:"p"},"double"),"'s domain."),(0,a.kt)("p",null,"Looks like our goal to program using pure functions is over..Or is it?"),(0,a.kt)("p",null,"We need to be able to refer to some ",(0,a.kt)("strong",{parentName:"p"},"rigorous theory"),", one able to answer such fundamental questions."),(0,a.kt)("p",null,"We need to refer to a ",(0,a.kt)("strong",{parentName:"p"},"formal definition")," of composability."),(0,a.kt)("p",null,"Luckily, for the last 70 years ago, a large number of researchers, members of the oldest and largest humanity's open source project (mathematics) occupied itself with developing a theory dedicated to composability: ",(0,a.kt)("strong",{parentName:"p"},"category theory"),", a branch of mathematics founded by Saunders Mac Lane along Samuel Eilenberg (1945)."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Categories capture the essence of composition.")),(0,a.kt)("p",null,"Saunders Mac Lane"),(0,a.kt)("center",null,(0,a.kt)("img",{src:"images/maclane.jpg",width:"300",alt:"Saunders Mac Lane"}),(0,a.kt)("p",null,"(Saunders Mac Lane)"),(0,a.kt)("img",{src:"images/eilenberg.jpg",width:"300",alt:"Samuel Eilenberg"}),(0,a.kt)("p",null,"(Samuel Eilenberg)")),(0,a.kt)("p",null,"We'll see in the following chapters how a category can form the basis for:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a model for a generic ",(0,a.kt)("strong",{parentName:"li"},"programming language")),(0,a.kt)("li",{parentName:"ul"},"a model for the concept of ",(0,a.kt)("strong",{parentName:"li"},"composition"))),(0,a.kt)("h2",{id:"definition"},"Definition"),(0,a.kt)("p",null,"The definition of a category, even though it isn't really complex, is a bit long, thus I'll split it in two parts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the first is merely technical (we need to define its constituents)"),(0,a.kt)("li",{parentName:"ul"},"the second one will be more relevant to what we care for: a notion of composition")),(0,a.kt)("h3",{id:"part-i-constituents"},"Part I (Constituents)"),(0,a.kt)("p",null,"A category is a pair of ",(0,a.kt)("inlineCode",{parentName:"p"},"(Objects, Morphisms)")," where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Objects")," is a collection of ",(0,a.kt)("strong",{parentName:"li"},"objects")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Morphisms")," is a collection of ",(0,a.kt)("strong",{parentName:"li"},"morphisms"),' (also called "arrows") between objects')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),'. The term "object" has nothing to do with the concept of "objects" in programming. Just think about those "objects" as black boxes we can\'t inspect, or simple placeholders useful to define the various morphisms.'),(0,a.kt)("p",null,"Every morphism ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," owns a source object ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and a target object ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),"."),(0,a.kt)("p",null,"In every morphism, both ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," are members of ",(0,a.kt)("inlineCode",{parentName:"p"},"Objects"),". We write ",(0,a.kt)("inlineCode",{parentName:"p"},"f: A \u27fc B"),' and we say that "f is a morphism from A to B".'),(0,a.kt)("img",{src:"images/morphism.png",width:"300",alt:"A morphism"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),". For simplicity, from now on, I'll use labels only for objects, skipping the circles."),(0,a.kt)("h3",{id:"part-ii-composition"},"Part II (Composition)"),(0,a.kt)("p",null,"There is an operation, ",(0,a.kt)("inlineCode",{parentName:"p"},"\u2218"),', called "composition", such as the following properties hold true:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"(",(0,a.kt)("strong",{parentName:"li"},"composition of morphisms"),") every time we have two morphisms ",(0,a.kt)("inlineCode",{parentName:"li"},"f: A \u27fc B")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"g: B \u27fc C")," in ",(0,a.kt)("inlineCode",{parentName:"li"},"Morphisms")," then there has to be a third morphism ",(0,a.kt)("inlineCode",{parentName:"li"},"g \u2218 f: A \u27fc C")," in ",(0,a.kt)("inlineCode",{parentName:"li"},"Morphisms")," which is the ",(0,a.kt)("em",{parentName:"li"},"composition")," of ",(0,a.kt)("inlineCode",{parentName:"li"},"f")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"g"))),(0,a.kt)("img",{src:"images/composition.png",width:"300",alt:"composition"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"(",(0,a.kt)("strong",{parentName:"li"},"associativity"),") if ",(0,a.kt)("inlineCode",{parentName:"li"},"f: A \u27fc B"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"g: B \u27fc C")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"h: C \u27fc D")," then ",(0,a.kt)("inlineCode",{parentName:"li"},"h \u2218 (g \u2218 f) = (h \u2218 g) \u2218 f"))),(0,a.kt)("img",{src:"images/associativity.png",width:"500",alt:"associativity"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"(",(0,a.kt)("strong",{parentName:"li"},"identity"),") for every object ",(0,a.kt)("inlineCode",{parentName:"li"},"X"),", there is a morphism ",(0,a.kt)("inlineCode",{parentName:"li"},"identity: X \u27fc X")," called ",(0,a.kt)("em",{parentName:"li"},"identity morphism")," of ",(0,a.kt)("inlineCode",{parentName:"li"},"X"),", such as for every morphism ",(0,a.kt)("inlineCode",{parentName:"li"},"f: A \u27fc X")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"g: X \u27fc B"),", the following equation holds true ",(0,a.kt)("inlineCode",{parentName:"li"},"identity \u2218 f = f")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"g \u2218 identity = g"),".")),(0,a.kt)("img",{src:"images/identity.png",width:"300",alt:"identity"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("img",{src:"images/category.png",width:"300",alt:"a simple category"}),(0,a.kt)("p",null,"This category is very simple, there are three objects and six morphisms (1",(0,a.kt)("sub",null,"A"),", 1",(0,a.kt)("sub",null,"B"),", 1",(0,a.kt)("sub",null,"C")," are the identity morphisms for ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"C"),")."),(0,a.kt)("h2",{id:"modeling-programming-languages-with-categories"},"Modeling programming languages with categories"),(0,a.kt)("p",null,"A category can be seen as a simplified model for a ",(0,a.kt)("strong",{parentName:"p"},"typed programming language"),", where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"objects are ",(0,a.kt)("strong",{parentName:"li"},"types")),(0,a.kt)("li",{parentName:"ul"},"morphisms are ",(0,a.kt)("strong",{parentName:"li"},"functions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"\u2218")," is the usual ",(0,a.kt)("strong",{parentName:"li"},"function composition"))),(0,a.kt)("p",null,"The following diagram:"),(0,a.kt)("img",{src:"images/category.png",width:"300",alt:"a simple programming language"}),(0,a.kt)("p",null,"can be seen as an imaginary (and simple) programming language with just three types and six functions"),(0,a.kt)("p",null,"Example given:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"A = string")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"B = number")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"C = boolean")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"f = string => number")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"g = number => boolean")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"g \u2218 f = string => boolean"))),(0,a.kt)("p",null,"The implementation could be something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const idA = (s: string): string => s\n\nconst idB = (n: number): number => n\n\nconst idC = (b: boolean): boolean => b\n\nconst f = (s: string): number => s.length\n\nconst g = (n: number): boolean => n > 2\n\n// gf = g \u2218 f\nconst gf = (s: string): boolean => g(f(s))\n")),(0,a.kt)("h2",{id:"a-category-for-typescript"},"A category for TypeScript"),(0,a.kt)("p",null,"We can define a category, let's call it ",(0,a.kt)("em",{parentName:"p"},"TS"),", as a simplified model of the TypeScript language, where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"objects")," are all the possible TypeScript types: ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"ReadonlyArray<string>"),", etc..."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"morphisms")," are all TypeScript functions: ",(0,a.kt)("inlineCode",{parentName:"li"},"(a: A) => B"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"(b: B) => C"),", ... where ",(0,a.kt)("inlineCode",{parentName:"li"},"A"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"B"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"C"),", ... are TypeScript types"),(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("strong",{parentName:"li"},"identity morphisms")," are all encoded in a single polymorphic function ",(0,a.kt)("inlineCode",{parentName:"li"},"const identity = <A>(a: A): A => a")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"morphism's composition")," is the usual function composition (which we know to be associative)")),(0,a.kt)("p",null,"As a model of TypeScript, the ",(0,a.kt)("em",{parentName:"p"},"TS")," category may seem a bit limited: no loops, no ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),"s, there's ",(0,a.kt)("em",{parentName:"p"},"almost")," nothing... that being said that simplified model is rich enough to help us reach our goal: to reason about a well-defined notion of composition."),(0,a.kt)("h2",{id:"compositions-core-problem"},"Composition's core problem"),(0,a.kt)("p",null,"In the ",(0,a.kt)("em",{parentName:"p"},"TS")," category we can compose two generic functions ",(0,a.kt)("inlineCode",{parentName:"p"},"f: (a: A) => B")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"g: (c: C) => D")," as long as ",(0,a.kt)("inlineCode",{parentName:"p"},"C = B")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function flow<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C {\n  return (a) => g(f(a))\n}\n\nfunction pipe<A, B, C>(a: A, f: (a: A) => B, g: (b: B) => C): C {\n  return flow(f, g)(a)\n}\n")),(0,a.kt)("p",null,"But what happens if ",(0,a.kt)("inlineCode",{parentName:"p"},"B != C"),"? How can we compose two such functions? Should we give up?"),(0,a.kt)("p",null,"In the next section we'll see under which conditions such a composition is possible."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Spoiler")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"to compose ",(0,a.kt)("inlineCode",{parentName:"li"},"f: (a: A) => B")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"g: (b: B) => C")," we use our usual function composition"),(0,a.kt)("li",{parentName:"ul"},"to compose ",(0,a.kt)("inlineCode",{parentName:"li"},"f: (a: A) => F<B>")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"g: (b: B) => C")," we need a ",(0,a.kt)("strong",{parentName:"li"},"functor")," instance for ",(0,a.kt)("inlineCode",{parentName:"li"},"F")),(0,a.kt)("li",{parentName:"ul"},"to compose ",(0,a.kt)("inlineCode",{parentName:"li"},"f: (a: A) => F<B>")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"g: (b: B, c: C) => D")," we need an ",(0,a.kt)("strong",{parentName:"li"},"applicative functor")," instance for ",(0,a.kt)("inlineCode",{parentName:"li"},"F")),(0,a.kt)("li",{parentName:"ul"},"to compose ",(0,a.kt)("inlineCode",{parentName:"li"},"f: (a: A) => F<B>")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"g: (b: B) => F<C>")," we need a ",(0,a.kt)("strong",{parentName:"li"},"monad")," instance for ",(0,a.kt)("inlineCode",{parentName:"li"},"F"))),(0,a.kt)("img",{src:"images/spoiler.png",width:"900",alt:"The four composition recipes"}),(0,a.kt)("p",null,"The problem we started with at the beginning of this chapter corresponds to the second situation, where ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Option")," type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// A = ReadonlyArray<number>, B = number, F = Option\nhead: (as: ReadonlyArray<number>) => Option<number>\ndouble: (n: number) => number\n")),(0,a.kt)("p",null,"To solve it, the next chapter will talk about functors."))}u.isMDXComponent=!0}}]);