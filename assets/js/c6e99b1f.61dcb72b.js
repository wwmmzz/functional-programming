"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[35],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),s=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(i.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=s(t),f=r,d=m["".concat(i,".").concat(f)]||m[f]||u[f]||o;return t?a.createElement(d,l(l({ref:n},c),{},{components:t})):a.createElement(d,l({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=f;var p={};for(var i in n)hasOwnProperty.call(n,i)&&(p[i]=n[i]);p.originalType=e,p[m]="string"==typeof e?e:r,l[1]=p;for(var s=2;s<o;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},7381:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const o={},l="Applicative functors",p={unversionedId:"Applicative functors",id:"Applicative functors",title:"Applicative functors",description:"In the section regarding functors we've seen that we can compose an effectful program f A) => F with a pure one g B) => C through the transformation of g to a function map(g) F) => F (if and only if F admits a functor instance).",source:"@site/docs/10. Applicative functors.md",sourceDirName:".",slug:"/Applicative functors",permalink:"/functional-programming/Applicative functors",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/10. Applicative functors.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Functors",permalink:"/functional-programming/Functors"},next:{title:"Monads",permalink:"/functional-programming/Monads"}},i={},s=[{value:"Currying",id:"currying",level:2},{value:"The <code>ap</code> operation",id:"the-ap-operation",level:2},{value:"The <code>of</code> operation",id:"the-of-operation",level:2},{value:"Applicative functors compose",id:"applicative-functors-compose",level:2},{value:"Do applicative functors solve the general problem?",id:"do-applicative-functors-solve-the-general-problem",level:2}],c={toc:s},m="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"applicative-functors"},"Applicative functors"),(0,r.kt)("p",null,"In the section regarding functors we've seen that we can compose an effectful program ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => F<B>")," with a pure one ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (b: B) => C")," through the transformation of ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," to a function ",(0,r.kt)("inlineCode",{parentName:"p"},"map(g): (fb: F<B>) => F<C>")," (if and only if ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," admits a functor instance)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Program f"),(0,r.kt)("th",{parentName:"tr",align:null},"Program g"),(0,r.kt)("th",{parentName:"tr",align:null},"Composition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"g \u2218 f"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"effectful"),(0,r.kt)("td",{parentName:"tr",align:null},"pure (unary)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map(g) \u2218 f"))))),(0,r.kt)("p",null,"But ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," has to be unary, it can only accept a single argument as input. What happens if ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," accepts two arguments? Can we still transform ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," using only the functor instance?"),(0,r.kt)("h2",{id:"currying"},"Currying"),(0,r.kt)("p",null,"First of all we need to model a function that accepts two arguments of type ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," (we can use a tuple for this) and returns a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"D"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"g: (b: B, c: C) => D\n")),(0,r.kt)("p",null,"We can rewrite ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," using a technique called ",(0,r.kt)("strong",{parentName:"p"},"currying"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, ",(0,r.kt)("strong",{parentName:"p"},"each with a single argument"),". For example, a function that takes two arguments, one from ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," and one from ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),", and produces outputs in ",(0,r.kt)("inlineCode",{parentName:"p"},"D"),", by currying is translated into a function that takes a single argument from ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," and produces as outputs functions from ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),".")),(0,r.kt)("p",null,"(source: ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Currying"},"currying on wikipedia.org"),")"),(0,r.kt)("p",null,"Thus, through currying, we can rewrite ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"g: (b: B) => (c: C) => D\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst addFollower = (follower: User, user: User): User => ({\n  ...user,\n  followers: [...user.followers, follower]\n})\n")),(0,r.kt)("p",null,"Let's refactor ",(0,r.kt)("inlineCode",{parentName:"p"},"addFollower")," through currying"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst addFollower = (follower: User) => (user: User): User => ({\n  ...user,\n  followers: [...user.followers, follower]\n})\n\n// -------------------\n// usage example\n// -------------------\n\nconst user: User = { id: 1, name: 'Ruth R. Gonzalez', followers: [] }\nconst follower: User = { id: 3, name: 'Marsha J. Joslyn', followers: [] }\n\nconsole.log(addFollower(follower)(user))\n/*\n{\n  id: 1,\n  name: 'Ruth R. Gonzalez',\n  followers: [ { id: 3, name: 'Marsha J. Joslyn', followers: [] } ]\n}\n*/\n")),(0,r.kt)("h2",{id:"the-ap-operation"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"ap")," operation"),(0,r.kt)("p",null,"Suppose that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we do not have a ",(0,r.kt)("inlineCode",{parentName:"li"},"follower")," but only his ",(0,r.kt)("inlineCode",{parentName:"li"},"id")),(0,r.kt)("li",{parentName:"ul"},"we do not have a ",(0,r.kt)("inlineCode",{parentName:"li"},"user")," but only his ",(0,r.kt)("inlineCode",{parentName:"li"},"id")),(0,r.kt)("li",{parentName:"ul"},"that we have an API ",(0,r.kt)("inlineCode",{parentName:"li"},"fetchUser")," which, given an ",(0,r.kt)("inlineCode",{parentName:"li"},"id"),", queries an endpoint that returns the corresponding ",(0,r.kt)("inlineCode",{parentName:"li"},"User"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as T from 'fp-ts/Task'\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst addFollower = (follower: User) => (user: User): User => ({\n  ...user,\n  followers: [...user.followers, follower]\n})\n\ndeclare const fetchUser: (id: number) => T.Task<User>\n\nconst userId = 1\nconst followerId = 3\n\nconst result = addFollower(fetchUser(followerId))(fetchUser(userId)) // does not compile\n")),(0,r.kt)("p",null,"I can't use ",(0,r.kt)("inlineCode",{parentName:"p"},"addFollower")," anymore! How can we proceed?"),(0,r.kt)("p",null,"If only we had a function with the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const addFollowerAsync: (\n  follower: T.Task<User>\n) => (user: T.Task<User>) => T.Task<User>\n")),(0,r.kt)("p",null,"we could proceed with ease:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as T from 'fp-ts/Task'\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\ndeclare const fetchUser: (id: number) => T.Task<User>\n\ndeclare const addFollowerAsync: (\n  follower: T.Task<User>\n) => (user: T.Task<User>) => T.Task<User>\n\nconst userId = 1\nconst followerId = 3\n\n// const result: T.Task<User>\nconst result = addFollowerAsync(fetchUser(followerId))(fetchUser(userId)) // now compiles\n")),(0,r.kt)("p",null,"We can obviously implement ",(0,r.kt)("inlineCode",{parentName:"p"},"addFollowerAsync")," manually, but is it possible instead to find a transformation which starting with a function like ",(0,r.kt)("inlineCode",{parentName:"p"},"addFollower: (follower: User) => (user: User): User")," returns a function like ",(0,r.kt)("inlineCode",{parentName:"p"},"addFollowerAsync: (follower: Task<User>) => (user: Task<User>) => Task<User>"),"?"),(0,r.kt)("p",null,"More generally what we would like to have is a transformation, call it ",(0,r.kt)("inlineCode",{parentName:"p"},"liftA2"),", which beginning with a function ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (b: B) => (c: C) => D")," returns a function with the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"liftA2(g): (fb: F<B>) => (fc: F<C>) => F<D>\n")),(0,r.kt)("img",{src:"images/liftA2.png",width:"500",alt:"liftA2"}),(0,r.kt)("p",null,"How can we obtain it? Given that ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," is now a unary function, we can leverage the functor instance and the good old ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"map(g): (fb: F<B>) => F<(c: C) => D>\n")),(0,r.kt)("img",{src:"images/liftA2-first-step.png",width:"500",alt:"liftA2 (first step)"}),(0,r.kt)("p",null,'Now we are blocked: there\'s no legal operation the functor instance provides us to "unpack" the type ',(0,r.kt)("inlineCode",{parentName:"p"},"F<(c: C) => D>")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"(fc: F<C>) => F<D>"),"."),(0,r.kt)("p",null,"We need to introduce a new operation ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," which realizes this unpacking:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const ap: <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>) => Task<B>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),'. Why is it names "ap"? Because it can be seen like some sort of function application.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// `apply` applies a function to a value\ndeclare const apply: <A>(a: A) => <B>(f: (a: A) => B) => B\n\ndeclare const ap: <A>(a: Task<A>) => <B>(f: Task<(a: A) => B>) => Task<B>\n// `ap` applies a function wrapped into an effect to a value wrapped into an effect\n")),(0,r.kt)("p",null,"Now that we have ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," we can define ",(0,r.kt)("inlineCode",{parentName:"p"},"liftA2"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\nconst liftA2 = <B, C, D>(g: (b: B) => (c: C) => D) => (fb: T.Task<B>) => (\n  fc: T.Task<C>\n): T.Task<D> => pipe(fb, T.map(g), T.ap(fc))\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst addFollower = (follower: User) => (user: User): User => ({\n  ...user,\n  followers: [...user.followers, follower]\n})\n\n// const addFollowerAsync: (fb: T.Task<User>) => (fc: T.Task<User>) => T.Task<User>\nconst addFollowerAsync = liftA2(addFollower)\n")),(0,r.kt)("p",null,"and finally, we can compose ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchUser")," with the previous result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow, pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\nconst liftA2 = <B, C, D>(g: (b: B) => (c: C) => D) => (fb: T.Task<B>) => (\n  fc: T.Task<C>\n): T.Task<D> => pipe(fb, T.map(g), T.ap(fc))\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst addFollower = (follower: User) => (user: User): User => ({\n  ...user,\n  followers: [...user.followers, follower]\n})\n\ndeclare const fetchUser: (id: number) => T.Task<User>\n\n// const program: (id: number) => (fc: T.Task<User>) => T.Task<User>\nconst program = flow(fetchUser, liftA2(addFollower))\n\nconst userId = 1\nconst followerId = 3\n\n// const result: T.Task<User>\nconst result = program(followerId)(fetchUser(userId))\n")),(0,r.kt)("p",null,"We have found a standard procedure to compose two functions ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => F<B>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (b: B, c: C) => D"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"we transform ",(0,r.kt)("inlineCode",{parentName:"li"},"g")," through currying in a function ",(0,r.kt)("inlineCode",{parentName:"li"},"g: (b: B) => (c: C) => D")),(0,r.kt)("li",{parentName:"ol"},"we define the ",(0,r.kt)("inlineCode",{parentName:"li"},"ap")," function for the effect ",(0,r.kt)("inlineCode",{parentName:"li"},"F")," (library function)"),(0,r.kt)("li",{parentName:"ol"},"we define the utility function ",(0,r.kt)("inlineCode",{parentName:"li"},"liftA2")," for the effect ",(0,r.kt)("inlineCode",{parentName:"li"},"F")," (library function)"),(0,r.kt)("li",{parentName:"ol"},"we obtain the composition ",(0,r.kt)("inlineCode",{parentName:"li"},"flow(f, liftA2(g))"))),(0,r.kt)("p",null,"Let's see how's the ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," operation implemented for some of the type constructors we've already seen:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = ReadonlyArray"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { increment, pipe } from 'fp-ts/function'\n\nconst ap = <A>(fa: ReadonlyArray<A>) => <B>(\n  fab: ReadonlyArray<(a: A) => B>\n): ReadonlyArray<B> => {\n  const out: Array<B> = []\n  for (const f of fab) {\n    for (const a of fa) {\n      out.push(f(a))\n    }\n  }\n  return out\n}\n\nconst double = (n: number): number => n * 2\n\npipe([double, increment], ap([1, 2, 3]), console.log) // => [ 2, 4, 6, 2, 3, 4 ]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Option"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\n\nconst ap = <A>(fa: O.Option<A>) => <B>(\n  fab: O.Option<(a: A) => B>\n): O.Option<B> =>\n  pipe(\n    fab,\n    O.match(\n      () => O.none,\n      (f) =>\n        pipe(\n          fa,\n          O.match(\n            () => O.none,\n            (a) => O.some(f(a))\n          )\n        )\n    )\n  )\n\nconst double = (n: number): number => n * 2\n\npipe(O.some(double), ap(O.some(1)), console.log) // => some(2)\npipe(O.some(double), ap(O.none), console.log) // => none\npipe(O.none, ap(O.some(1)), console.log) // => none\npipe(O.none, ap(O.none), console.log) // => none\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = IO"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\n\nconst ap = <A>(fa: IO<A>) => <B>(fab: IO<(a: A) => B>): IO<B> => () => {\n  const f = fab()\n  const a = fa()\n  return f(a)\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Task"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Task } from 'fp-ts/Task'\n\nconst ap = <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>): Task<B> => () =>\n  Promise.all([fab(), fa()]).then(([f, a]) => f(a))\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Reader"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Reader } from 'fp-ts/Reader'\n\nconst ap = <R, A>(fa: Reader<R, A>) => <B>(\n  fab: Reader<R, (a: A) => B>\n): Reader<R, B> => (r) => {\n  const f = fab(r)\n  const a = fa(r)\n  return f(a)\n}\n")),(0,r.kt)("p",null,"We've seen how with ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," we can manage functions with two parameters, but what happens with functions that take ",(0,r.kt)("strong",{parentName:"p"},"three")," parameters? Do we need ",(0,r.kt)("em",{parentName:"p"},"yet another abstraction"),"?"),(0,r.kt)("p",null,"Good news is no, ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," are sufficient:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\nconst liftA3 = <B, C, D, E>(f: (b: B) => (c: C) => (d: D) => E) => (\n  fb: T.Task<B>\n) => (fc: T.Task<C>) => (fd: T.Task<D>): T.Task<E> =>\n  pipe(fb, T.map(f), T.ap(fc), T.ap(fd))\n\nconst liftA4 = <B, C, D, E, F>(\n  f: (b: B) => (c: C) => (d: D) => (e: E) => F\n) => (fb: T.Task<B>) => (fc: T.Task<C>) => (fd: T.Task<D>) => (\n  fe: T.Task<E>\n): T.Task<F> => pipe(fb, T.map(f), T.ap(fc), T.ap(fd), T.ap(fe))\n\n// etc...\n")),(0,r.kt)("p",null,'Now we cam update ore "composition table":'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Program f"),(0,r.kt)("th",{parentName:"tr",align:null},"Program g"),(0,r.kt)("th",{parentName:"tr",align:null},"Composition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},"pure"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"g \u2218 f"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"effectful"),(0,r.kt)("td",{parentName:"tr",align:null},"pure (unary)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map(g) \u2218 f"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"effectful"),(0,r.kt)("td",{parentName:"tr",align:null},"pure, ",(0,r.kt)("inlineCode",{parentName:"td"},"n"),"-ary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"liftAn(g) \u2218 f"))))),(0,r.kt)("h2",{id:"the-of-operation"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"of")," operation"),(0,r.kt)("p",null,"Now we know that given two function ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (a: A) => F<B>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"g: (b: B, c: C) => D")," we can obtain the composition ",(0,r.kt)("inlineCode",{parentName:"p"},"h"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"h: (a: A) => (fc: F<C>) => F<D>\n")),(0,r.kt)("p",null,"To execute ",(0,r.kt)("inlineCode",{parentName:"p"},"h")," we need a new value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"F<C>"),"."),(0,r.kt)("p",null,"But what happens if, instead of having a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"F<C>"),", for the second parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"fc")," we only have a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"C"),"?"),(0,r.kt)("p",null,"It would be helpful to have an operation which can transform a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," in a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"F<C>")," in order to use ",(0,r.kt)("inlineCode",{parentName:"p"},"h"),"."),(0,r.kt)("p",null,"Let's introduce such operation, called ",(0,r.kt)("inlineCode",{parentName:"p"},"of")," (other synonyms: ",(0,r.kt)("strong",{parentName:"p"},"pure"),", ",(0,r.kt)("strong",{parentName:"p"},"return"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const of: <C>(c: C) => F<C>\n")),(0,r.kt)("p",null,"In literature the term ",(0,r.kt)("strong",{parentName:"p"},"applicative functors")," is used for the type constructors which admith ",(0,r.kt)("em",{parentName:"p"},"both")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"of")," operations."),(0,r.kt)("p",null,"Let's see how ",(0,r.kt)("inlineCode",{parentName:"p"},"of")," is defined for some type constructors we've already seen:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = ReadonlyArray"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const of = <A>(a: A): ReadonlyArray<A> => [a]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Option"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as O from 'fp-ts/Option'\n\nconst of = <A>(a: A): O.Option<A> => O.some(a)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = IO"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\n\nconst of = <A>(a: A): IO<A> => () => a\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Task"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Task } from 'fp-ts/Task'\n\nconst of = <A>(a: A): Task<A> => () => Promise.resolve(a)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Reader"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Reader } from 'fp-ts/Reader'\n\nconst of = <R, A>(a: A): Reader<R, A> => () => a\n")),(0,r.kt)("h2",{id:"applicative-functors-compose"},"Applicative functors compose"),(0,r.kt)("p",null,"Applicative functors compose, meaning that given two applicative functors ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"G"),", their composition ",(0,r.kt)("inlineCode",{parentName:"p"},"F<G<A>>")," is still an applicative functor."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," (",(0,r.kt)("inlineCode",{parentName:"p"},"F = Task"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"G = Option"),")"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"of")," of the composition is the composition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"of"),"s:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as T from 'fp-ts/Task'\n\ntype TaskOption<A> = T.Task<O.Option<A>>\n\nconst of: <A>(a: A) => TaskOption<A> = flow(O.of, T.of)\n")),(0,r.kt)("p",null,"the ",(0,r.kt)("inlineCode",{parentName:"p"},"ap")," of the composition is obtained by the following pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const ap = <A>(\n  fa: TaskOption<A>\n): (<B>(fab: TaskOption<(a: A) => B>) => TaskOption<B>) =>\n  flow(\n    T.map((gab) => (ga: O.Option<A>) => O.ap(ga)(gab)),\n    T.ap(fa)\n  )\n")),(0,r.kt)("h2",{id:"do-applicative-functors-solve-the-general-problem"},"Do applicative functors solve the general problem?"),(0,r.kt)("p",null,"Not yet. There's one last very important case to consider: when ",(0,r.kt)("strong",{parentName:"p"},"both")," programs are effectful."),(0,r.kt)("p",null,"Yet again we need something more, in the following chapter we'll talk about one of the most important abstractions in functional programming: ",(0,r.kt)("strong",{parentName:"p"},"monads"),"."))}u.isMDXComponent=!0}}]);