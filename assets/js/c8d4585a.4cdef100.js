"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[76],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(t),c=r,f=d["".concat(p,".").concat(c)]||d[c]||u[c]||o;return t?a.createElement(f,i(i({ref:n},m),{},{components:t})):a.createElement(f,i({ref:n},m))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},7939:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const o={},i="Modelling equivalence with Eq",l={unversionedId:"Modelling equivalence with Eq",id:"Modelling equivalence with Eq",title:"Modelling equivalence with Eq",description:"Yet again, we can model the notion of equality.",source:"@site/docs/4. Modelling equivalence with Eq.md",sourceDirName:".",slug:"/Modelling equivalence with Eq",permalink:"/functional-programming/Modelling equivalence with Eq",draft:!1,editUrl:"https://github.com/wwmmzz/functional-programming/blob/master/website/docs/4. Modelling equivalence with Eq.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Modelling composition with Semigroups",permalink:"/functional-programming/Modelling composition with Semigroups"},next:{title:"Modeling composition through Monoids",permalink:"/functional-programming/Modeling composition through Monoids"}},p={},s=[{value:"Modeling ordering relations with <code>Ord</code>",id:"modeling-ordering-relations-with-ord",level:2},{value:"Dual Ordering",id:"dual-ordering",level:2}],m={toc:s},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"modelling-equivalence-with-eq"},"Modelling equivalence with ",(0,r.kt)("inlineCode",{parentName:"h1"},"Eq")),(0,r.kt)("p",null,"Yet again, we can model the notion of equality."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Equivalence relations")," capture the concept of ",(0,r.kt)("em",{parentName:"p"},"equality")," of elements of the same type. The concept of an ",(0,r.kt)("em",{parentName:"p"},"equivalence relation")," can be implemented in TypeScript with the following interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface Eq<A> {\n  readonly equals: (first: A, second: A) => boolean\n}\n")),(0,r.kt)("p",null,"Intuitively:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, y) = true")," then we say ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," are equal"),(0,r.kt)("li",{parentName:"ul"},"if ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, y) = false")," then we say ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," are different")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"This is an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/Eq'\nimport { pipe } from 'fp-ts/function'\n\nconst EqNumber: Eq<number> = {\n  equals: (first, second) => first === second\n}\n\npipe(EqNumber.equals(1, 1), console.log) // => true\npipe(EqNumber.equals(1, 2), console.log) // => false\n")),(0,r.kt)("p",null,"The following laws have to hold true:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reflexivity"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, x) === true"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Symmetry"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, y) === equals(y, x)"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Transitivity"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, y) === true")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(y, z) === true"),", then ",(0,r.kt)("inlineCode",{parentName:"li"},"equals(x, z) === true"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"y"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"z")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Would a combinator ",(0,r.kt)("inlineCode",{parentName:"p"},"reverse: <A>(E: Eq<A>) => Eq<A>")," make sense?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Would a combinator ",(0,r.kt)("inlineCode",{parentName:"p"},"not: <A>(E: Eq<A>) => Eq<A>")," make sense?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/Eq'\n\nexport const not = <A>(E: Eq<A>): Eq<A> => ({\n  equals: (first, second) => !E.equals(first, second)\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's see the first example of the usage of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," abstraction by defining a function ",(0,r.kt)("inlineCode",{parentName:"p"},"elem")," that checks whether a given value is an element of ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyArray"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/Eq'\nimport { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\n\n// returns `true` if the element `a` is included in the list `as`\nconst elem = <A>(E: Eq<A>) => (a: A) => (as: ReadonlyArray<A>): boolean =>\n  as.some((e) => E.equals(a, e))\n\npipe([1, 2, 3], elem(N.Eq)(2), console.log) // => true\npipe([1, 2, 3], elem(N.Eq)(4), console.log) // => false\n")),(0,r.kt)("p",null,"Why would we not use the native ",(0,r.kt)("inlineCode",{parentName:"p"},"includes")," Array method?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"console.log([1, 2, 3].includes(2)) // => true\nconsole.log([1, 2, 3].includes(4)) // => false\n")),(0,r.kt)("p",null,"Let's define some ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for more complex types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/Eq'\n\ntype Point = {\n  readonly x: number\n  readonly y: number\n}\n\nconst EqPoint: Eq<Point> = {\n  equals: (first, second) => first.x === second.x && first.y === second.y\n}\n\nconsole.log(EqPoint.equals({ x: 1, y: 2 }, { x: 1, y: 2 })) // => true\nconsole.log(EqPoint.equals({ x: 1, y: 2 }, { x: 1, y: -2 })) // => false\n")),(0,r.kt)("p",null,"and check the results of ",(0,r.kt)("inlineCode",{parentName:"p"},"elem")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"includes")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const points: ReadonlyArray<Point> = [\n  { x: 0, y: 0 },\n  { x: 1, y: 1 },\n  { x: 2, y: 2 }\n]\n\nconst search: Point = { x: 1, y: 1 }\n\nconsole.log(points.includes(search)) // => false :(\nconsole.log(pipe(points, elem(EqPoint)(search))) // => true :)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz")," (JavaScript). Why does the ",(0,r.kt)("inlineCode",{parentName:"p"},"includes")," method returns ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"?"),(0,r.kt)("p",null,"-> See the ",(0,r.kt)("a",{parentName:"p",href:"/functional-programming/quiz-answers/javascript-includes"},"answer here")),(0,r.kt)("p",null,"Abstracting the concept of equality is of paramount importance, especially in a language like JavaScript where some data types do not offer handy APIs for checking user-defined equality."),(0,r.kt)("p",null,"The JavaScript native ",(0,r.kt)("inlineCode",{parentName:"p"},"Set")," datatype suffers by the same issue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Point = {\n  readonly x: number\n  readonly y: number\n}\n\nconst points: Set<Point> = new Set([{ x: 0, y: 0 }])\n\npoints.add({ x: 0, y: 0 })\n\nconsole.log(points)\n// => Set { { x: 0, y: 0 }, { x: 0, y: 0 } }\n")),(0,r.kt)("p",null,"Given the fact that ",(0,r.kt)("inlineCode",{parentName:"p"},"Set")," uses ",(0,r.kt)("inlineCode",{parentName:"p"},"==="),' ("strict equality") for comparing values, ',(0,r.kt)("inlineCode",{parentName:"p"},"points")," now contains ",(0,r.kt)("strong",{parentName:"p"},"two identical copies")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"{ x: 0, y: 0 }"),", a result we definitely did not want. Thus it is convenient to define a new API to add an element to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Set"),", one that leverages the ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," abstraction."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". What would be the signature of this API?"),(0,r.kt)("p",null,"Does ",(0,r.kt)("inlineCode",{parentName:"p"},"EqPoint")," require too much boilerplate? The good news is that theory offers us yet again the possibility of implementing an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for a struct like ",(0,r.kt)("inlineCode",{parentName:"p"},"Point")," if we are able to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for each of its fields."),(0,r.kt)("p",null,"Conveniently the ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts/Eq")," module exports a ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," combinator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq, struct } from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\n\ntype Point = {\n  readonly x: number\n  readonly y: number\n}\n\nconst EqPoint: Eq<Point> = struct({\n  x: N.Eq,\n  y: N.Eq\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),". Like for Semigroup, we aren't limited to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),"-like data types, we also have combinators for working with tuples: ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq, tuple } from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\n\ntype Point = readonly [number, number]\n\nconst EqPoint: Eq<Point> = tuple(N.Eq, N.Eq)\n\nconsole.log(EqPoint.equals([1, 2], [1, 2])) // => true\nconsole.log(EqPoint.equals([1, 2], [1, -2])) // => false\n")),(0,r.kt)("p",null,"There are other combinators exported by ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts"),", here we can see a combinator that allows us to derive an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyArray"),"s."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq, tuple } from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\nimport * as RA from 'fp-ts/ReadonlyArray'\n\ntype Point = readonly [number, number]\n\nconst EqPoint: Eq<Point> = tuple(N.Eq, N.Eq)\n\nconst EqPoints: Eq<ReadonlyArray<Point>> = RA.getEq(EqPoint)\n")),(0,r.kt)("p",null,"Similarly to Semigroups, it is possible to define more than one ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for the same given type. Suppose we have modeled a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," with the following type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type User = {\n  readonly id: number\n  readonly name: string\n}\n")),(0,r.kt)("p",null,'we can define a "standard" ',(0,r.kt)("inlineCode",{parentName:"p"},"Eq<User>")," instance using the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," combinator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq, struct } from 'fp-ts/Eq'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\n\ntype User = {\n  readonly id: number\n  readonly name: string\n}\n\nconst EqStandard: Eq<User> = struct({\n  id: N.Eq,\n  name: S.Eq\n})\n")),(0,r.kt)("p",null,"Several languages, even pure functional languages like Haskell, do not allow to have more than one ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance per data type. But we may have different contexts where the meaning of ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," equality might differ. One common context is where two ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"s are equal if their ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," field is equal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/** two users are equal if their `id` fields are equal */\nconst EqID: Eq<User> = {\n  equals: (first, second) => N.Eq.equals(first.id, second.id)\n}\n")),(0,r.kt)("p",null,"Now that we made an abstract concept concrete by representing it as a data structure, we can programmatically manipulate ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instances like we do with other data structures. Let's see an example."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),". Rather than manually defining ",(0,r.kt)("inlineCode",{parentName:"p"},"EqId")," we can use the combinator ",(0,r.kt)("inlineCode",{parentName:"p"},"contramap"),": given an instance ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq<A>")," and a function from ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", we can derive an ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq<B>")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq, struct, contramap } from 'fp-ts/Eq'\nimport { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\n\ntype User = {\n  readonly id: number\n  readonly name: string\n}\n\nconst EqStandard: Eq<User> = struct({\n  id: N.Eq,\n  name: S.Eq\n})\n\nconst EqID: Eq<User> = pipe(\n  N.Eq,\n  contramap((user: User) => user.id)\n)\n\nconsole.log(\n  EqStandard.equals({ id: 1, name: 'Giulio' }, { id: 1, name: 'Giulio Canti' })\n) // => false (because the `name` property differs)\n\nconsole.log(\n  EqID.equals({ id: 1, name: 'Giulio' }, { id: 1, name: 'Giulio Canti' })\n) // => true (even though the `name` property differs)\n\nconsole.log(EqID.equals({ id: 1, name: 'Giulio' }, { id: 2, name: 'Giulio' }))\n// => false (even though the `name` property is equal)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Given a data type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", is it possible to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup<Eq<A>>"),"? What could it represent?"),(0,r.kt)("h2",{id:"modeling-ordering-relations-with-ord"},"Modeling ordering relations with ",(0,r.kt)("inlineCode",{parentName:"h2"},"Ord")),(0,r.kt)("p",null,"In the previous chapter regarding ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," we were dealing with the concept of ",(0,r.kt)("strong",{parentName:"p"},"equality"),". In this one we'll deal with the concept of ",(0,r.kt)("strong",{parentName:"p"},"ordering"),"."),(0,r.kt)("p",null,"The concept of a total order relation can be implemented in TypeScript as following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Eq } from 'fp-ts/lib/Eq'\n\ntype Ordering = -1 | 0 | 1\n\ninterface Ord<A> extends Eq<A> {\n  readonly compare: (x: A, y: A) => Ordering\n}\n")),(0,r.kt)("p",null,"Resulting in:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x < y")," if and only if ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, y) = -1")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x = y")," if and only if ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, y) = 0")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x > y")," if and only if ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, y) = 1"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's try to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," instance for the type ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Ord } from 'fp-ts/Ord'\n\nconst OrdNumber: Ord<number> = {\n  equals: (first, second) => first === second,\n  compare: (first, second) => (first < second ? -1 : first > second ? 1 : 0)\n}\n")),(0,r.kt)("p",null,"The following laws have to hold true:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reflexivity"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, x) <= 0"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Antisymmetry"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, y) <= 0")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(y, x) <= 0")," then ",(0,r.kt)("inlineCode",{parentName:"li"},"x = y"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Transitivity"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, y) <= 0")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(y, z) <= 0")," then ",(0,r.kt)("inlineCode",{parentName:"li"},"compare(x, z) <= 0"),", for every ",(0,r.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"y"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"z")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"A"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"compare")," has also to be compatible with the ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," operation from ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq"),":"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"compare(x, y) === 0")," if and only if ",(0,r.kt)("inlineCode",{parentName:"p"},"equals(x, y) === true"),", for every ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"A")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," can be derived from ",(0,r.kt)("inlineCode",{parentName:"p"},"compare")," in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"equals: (first, second) => compare(first, second) === 0\n")),(0,r.kt)("p",null,"In fact the ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts/Ord")," module exports a handy helper ",(0,r.kt)("inlineCode",{parentName:"p"},"fromCompare")," which allows us to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," instance simply by supplying the ",(0,r.kt)("inlineCode",{parentName:"p"},"compare")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Ord, fromCompare } from 'fp-ts/Ord'\n\nconst OrdNumber: Ord<number> = fromCompare((first, second) =>\n  first < second ? -1 : first > second ? 1 : 0\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Is it possible to define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," instance for the game Rock-Paper-Scissor where ",(0,r.kt)("inlineCode",{parentName:"p"},"move1 <= move2")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"move2")," beats ",(0,r.kt)("inlineCode",{parentName:"p"},"move1"),"?"),(0,r.kt)("p",null,"Let's see a practical usage of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," instance by defining a ",(0,r.kt)("inlineCode",{parentName:"p"},"sort")," function which orders the elements of a ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyArray"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { Ord } from 'fp-ts/Ord'\n\nexport const sort = <A>(O: Ord<A>) => (\n  as: ReadonlyArray<A>\n): ReadonlyArray<A> => as.slice().sort(O.compare)\n\npipe([3, 1, 2], sort(N.Ord), console.log) // => [1, 2, 3]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz")," (JavaScript). Why does the implementation leverages the native Array ",(0,r.kt)("inlineCode",{parentName:"p"},"slice")," method?"),(0,r.kt)("p",null,"Let's see another ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," pratical usage by defining a ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," function that returns the smallest of two values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { Ord } from 'fp-ts/Ord'\n\nconst min = <A>(O: Ord<A>) => (second: A) => (first: A): A =>\n  O.compare(first, second) === 1 ? second : first\n\npipe(2, min(N.Ord)(1), console.log) // => 1\n")),(0,r.kt)("h2",{id:"dual-ordering"},"Dual Ordering"),(0,r.kt)("p",null,"In the same way we could invert the ",(0,r.kt)("inlineCode",{parentName:"p"},"concat")," operation to obtain the ",(0,r.kt)("inlineCode",{parentName:"p"},"dual semigroup")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"reverse")," combinator, we can invert the ",(0,r.kt)("inlineCode",{parentName:"p"},"compare")," operation to get the dual ordering."),(0,r.kt)("p",null,"Let's define the ",(0,r.kt)("inlineCode",{parentName:"p"},"reverse")," combinator for ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { fromCompare, Ord } from 'fp-ts/Ord'\n\nexport const reverse = <A>(O: Ord<A>): Ord<A> =>\n  fromCompare((first, second) => O.compare(second, first))\n")),(0,r.kt)("p",null,"A usage example for ",(0,r.kt)("inlineCode",{parentName:"p"},"reverse")," is obtaining a ",(0,r.kt)("inlineCode",{parentName:"p"},"max")," function from the ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow, pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { Ord, reverse } from 'fp-ts/Ord'\n\nconst min = <A>(O: Ord<A>) => (second: A) => (first: A): A =>\n  O.compare(first, second) === 1 ? second : first\n\n// const max: <A>(O: Ord<A>) => (second: A) => (first: A) => A\nconst max = flow(reverse, min)\n\npipe(2, max(N.Ord)(1), console.log) // => 2\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"totality")," of ordering (meaning that given any ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", one of the two conditions needs to hold true: ",(0,r.kt)("inlineCode",{parentName:"p"},"x <= y")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"y <= z"),") may appear obvious when speaking about numbers, but that's not always the case. Let's see a slightly more complex scenario:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type User = {\n  readonly name: string\n  readonly age: number\n}\n")),(0,r.kt)("p",null,"It's not really clear when a ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),' is "smaller or equal" than another ',(0,r.kt)("inlineCode",{parentName:"p"},"User"),"."),(0,r.kt)("p",null,"How can we define an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord<User>")," instance?"),(0,r.kt)("p",null,"That depends on the context, but a possible choice might be ordering ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"s by their age:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as N from 'fp-ts/number'\nimport { fromCompare, Ord } from 'fp-ts/Ord'\n\ntype User = {\n  readonly name: string\n  readonly age: number\n}\n\nconst byAge: Ord<User> = fromCompare((first, second) =>\n  N.Ord.compare(first.age, second.age)\n)\n")),(0,r.kt)("p",null,"Again we can get rid of some boilerplate using the ",(0,r.kt)("inlineCode",{parentName:"p"},"contramap")," combinatorL given an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord<A>")," instance and a function from ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", it is possible to derive ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord<B>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { contramap, Ord } from 'fp-ts/Ord'\n\ntype User = {\n  readonly name: string\n  readonly age: number\n}\n\nconst byAge: Ord<User> = pipe(\n  N.Ord,\n  contramap((_: User) => _.age)\n)\n")),(0,r.kt)("p",null,"We can get the youngest of two ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"s using the previously defined ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// const getYounger: (second: User) => (first: User) => User\nconst getYounger = min(byAge)\n\npipe(\n  { name: 'Guido', age: 50 },\n  getYounger({ name: 'Giulio', age: 47 }),\n  console.log\n) // => { name: 'Giulio', age: 47 }\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". In the ",(0,r.kt)("inlineCode",{parentName:"p"},"fp-ts/ReadonlyMap")," module the following API is exposed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Get a sorted `ReadonlyArray` of the keys contained in a `ReadonlyMap`.\n */\ndeclare const keys: <K>(\n  O: Ord<K>\n) => <A>(m: ReadonlyMap<K, A>) => ReadonlyArray<K>\n")),(0,r.kt)("p",null,"why does this API requires an instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord<K>"),"?"),(0,r.kt)("p",null,"Let's finally go back to the very first issue: defining two semigroups ",(0,r.kt)("inlineCode",{parentName:"p"},"SemigroupMin")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SemigroupMax")," for types different than ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Semigroup } from 'fp-ts/Semigroup'\n\nconst SemigroupMin: Semigroup<number> = {\n  concat: (first, second) => Math.min(first, second)\n}\n\nconst SemigroupMax: Semigroup<number> = {\n  concat: (first, second) => Math.max(first, second)\n}\n")),(0,r.kt)("p",null,"Now that we have the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," abstraction we can do it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { Ord, contramap } from 'fp-ts/Ord'\nimport { Semigroup } from 'fp-ts/Semigroup'\n\nexport const min = <A>(O: Ord<A>): Semigroup<A> => ({\n  concat: (first, second) => (O.compare(first, second) === 1 ? second : first)\n})\n\nexport const max = <A>(O: Ord<A>): Semigroup<A> => ({\n  concat: (first, second) => (O.compare(first, second) === 1 ? first : second)\n})\n\ntype User = {\n  readonly name: string\n  readonly age: number\n}\n\nconst byAge: Ord<User> = pipe(\n  N.Ord,\n  contramap((_: User) => _.age)\n)\n\nconsole.log(\n  min(byAge).concat({ name: 'Guido', age: 50 }, { name: 'Giulio', age: 47 })\n) // => { name: 'Giulio', age: 47 }\nconsole.log(\n  max(byAge).concat({ name: 'Guido', age: 50 }, { name: 'Giulio', age: 47 })\n) // => { name: 'Guido', age: 50 }\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's recap all of this with one final example (adapted from ",(0,r.kt)("a",{parentName:"p",href:"http://www.tomharding.me/2017/03/13/fantas-eel-and-specification-4/"},"Fantas, Eel, and Specification 4: Semigroup"),")."),(0,r.kt)("p",null,"Suppose we need to build a system where, in a database, there are records of customers implemented in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface Customer {\n  readonly name: string\n  readonly favouriteThings: ReadonlyArray<string>\n  readonly registeredAt: number // since epoch\n  readonly lastUpdatedAt: number // since epoch\n  readonly hasMadePurchase: boolean\n}\n")),(0,r.kt)("p",null,"For some reason, there might be duplicate records for the same person."),(0,r.kt)("p",null,"We need a merging strategy. Well, that's Semigroup's bread and butter!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import * as B from 'fp-ts/boolean'\nimport { pipe } from 'fp-ts/function'\nimport * as N from 'fp-ts/number'\nimport { contramap } from 'fp-ts/Ord'\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { max, min, Semigroup, struct } from 'fp-ts/Semigroup'\nimport * as S from 'fp-ts/string'\n\ninterface Customer {\n  readonly name: string\n  readonly favouriteThings: ReadonlyArray<string>\n  readonly registeredAt: number // since epoch\n  readonly lastUpdatedAt: number // since epoch\n  readonly hasMadePurchase: boolean\n}\n\nconst SemigroupCustomer: Semigroup<Customer> = struct({\n  // keep the longer name\n  name: max(pipe(N.Ord, contramap(S.size))),\n  // accumulate things\n  favouriteThings: RA.getSemigroup<string>(),\n  // keep the least recent date\n  registeredAt: min(N.Ord),\n  // keep the most recent date\n  lastUpdatedAt: max(N.Ord),\n  // boolean semigroup under disjunction\n  hasMadePurchase: B.SemigroupAny\n})\n\nconsole.log(\n  SemigroupCustomer.concat(\n    {\n      name: 'Giulio',\n      favouriteThings: ['math', 'climbing'],\n      registeredAt: new Date(2018, 1, 20).getTime(),\n      lastUpdatedAt: new Date(2018, 2, 18).getTime(),\n      hasMadePurchase: false\n    },\n    {\n      name: 'Giulio Canti',\n      favouriteThings: ['functional programming'],\n      registeredAt: new Date(2018, 1, 22).getTime(),\n      lastUpdatedAt: new Date(2018, 2, 9).getTime(),\n      hasMadePurchase: true\n    }\n  )\n)\n/*\n{ name: 'Giulio Canti',\n  favouriteThings: [ 'math', 'climbing', 'functional programming' ],\n  registeredAt: 1519081200000, // new Date(2018, 1, 20).getTime()\n  lastUpdatedAt: 1521327600000, // new Date(2018, 2, 18).getTime()\n  hasMadePurchase: true\n}\n*/\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Quiz"),". Given a type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," is it possible to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup<Ord<A>>")," instance? What could it possibly represent?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Demo")))}u.isMDXComponent=!0}}]);