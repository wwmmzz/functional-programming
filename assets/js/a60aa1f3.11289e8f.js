"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[282],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(t),f=i,u=d["".concat(p,".").concat(f)]||d[f]||c[f]||r;return t?a.createElement(u,o(o({ref:n},m),{},{components:t})):a.createElement(u,o({ref:n},m))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=f;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},3173:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={},o="Monads",l={unversionedId:"Monads",id:"Monads",title:"Monads",description:"(Eugenio Moggi is a professor of computer science at the University of Genoa, Italy. He first described the general use of monads to structure programs)",source:"@site/docs/11. Monads.md",sourceDirName:".",slug:"/Monads",permalink:"/functional-programming/Monads",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/11. Monads.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Applicative functors",permalink:"/functional-programming/Applicative functors"},next:{title:"for-loop",permalink:"/functional-programming/quiz-answers/for-loop"}},p={},s=[{value:"The problem with nested contexts",id:"the-problem-with-nested-contexts",level:2},{value:"Monad Definition",id:"monad-definition",level:2},{value:"The Kleisli category",id:"the-kleisli-category",level:2},{value:"Defining <code>chain</code> step by step",id:"defining-chain-step-by-step",level:2},{value:"Manipulating programs",id:"manipulating-programs",level:2}],m={toc:s},d="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"monads"},"Monads"),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/moggi.jpg",width:"300",alt:"Eugenio Moggi"}),(0,i.kt)("p",null,"(Eugenio Moggi is a professor of computer science at the University of Genoa, Italy. He first described the general use of monads to structure programs)"),(0,i.kt)("img",{src:"images/wadler.jpg",width:"300",alt:"Philip Lee Wadler"}),(0,i.kt)("p",null,"(Philip Lee Wadler is an American computer scientist known for his contributions to programming language design and type theory)")),(0,i.kt)("p",null,"In the last chapter we have seen how we can compose an effectful program ",(0,i.kt)("inlineCode",{parentName:"p"},"f: (a: A) => F<B>")," with an ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"-ary pure program ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", if and only if the type constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," admits an applicative functor instance:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Program f"),(0,i.kt)("th",{parentName:"tr",align:null},"Program g"),(0,i.kt)("th",{parentName:"tr",align:null},"Composition"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pure"),(0,i.kt)("td",{parentName:"tr",align:null},"pure"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"g \u2218 f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},"pure (unary)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"map(g) \u2218 f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},"pure, ",(0,i.kt)("inlineCode",{parentName:"td"},"n"),"-ary"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"liftAn(g) \u2218 f"))))),(0,i.kt)("p",null,"But we need to solve one last, quite common, case: when ",(0,i.kt)("strong",{parentName:"p"},"both")," programs are effectful:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"f: (a: A) => F<B>\ng: (b: B) => F<C>\n")),(0,i.kt)("p",null,"What is the composition of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),"?"),(0,i.kt)("h2",{id:"the-problem-with-nested-contexts"},"The problem with nested contexts"),(0,i.kt)("p",null,"Let's see few examples on why we need something more."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = Array"),")"),(0,i.kt)("p",null,"Suppose we want to get followers' followers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as A from 'fp-ts/ReadonlyArray'\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst getFollowers = (user: User): ReadonlyArray<User> => user.followers\n\ndeclare const user: User\n\n// followersOfFollowers: ReadonlyArray<ReadonlyArray<User>>\nconst followersOfFollowers = pipe(user, getFollowers, A.map(getFollowers))\n")),(0,i.kt)("p",null,"There's something wrong here, ",(0,i.kt)("inlineCode",{parentName:"p"},"followersOfFollowers")," has a type ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<ReadonlyArray<User>>")," but we want ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<User>"),"."),(0,i.kt)("p",null,"We need to ",(0,i.kt)("strong",{parentName:"p"},"flatten")," nested arrays."),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten: <A>(mma: ReadonlyArray<ReadonlyArray<A>>) => ReadonlyArray<A>")," exported by the ",(0,i.kt)("inlineCode",{parentName:"p"},"fp-ts/ReadonlyArray")," is exactly what we need:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// followersOfFollowers: ReadonlyArray<User>\nconst followersOfFollowers = pipe(\n  user,\n  getFollowers,\n  A.map(getFollowers),\n  A.flatten\n)\n")),(0,i.kt)("p",null,"Cool! Let's see some other data type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = Option"),")\nSuppose you want to calculate the reciprocal of the first element of a numerical array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as A from 'fp-ts/ReadonlyArray'\n\nconst inverse = (n: number): O.Option<number> =>\n  n === 0 ? O.none : O.some(1 / n)\n\n// inverseHead: O.Option<O.Option<number>>\nconst inverseHead = pipe([1, 2, 3], A.head, O.map(inverse))\n")),(0,i.kt)("p",null,"Oops, it happened again, ",(0,i.kt)("inlineCode",{parentName:"p"},"inverseHead")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<Option<number>>")," but we want ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<number>"),"."),(0,i.kt)("p",null,"We need to flatten again the nested ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),"s."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten: <A>(mma: Option<Option<A>>) => Option<A>")," function exported by the ",(0,i.kt)("inlineCode",{parentName:"p"},"fp-ts/Option")," module is what we need:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// inverseHead: O.Option<number>\nconst inverseHead = pipe([1, 2, 3], A.head, O.map(inverse), O.flatten)\n")),(0,i.kt)("p",null,"All of those ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten")," funcitons...They aren't a coincidence, there is a functional pattern behind the scenes: both the type constructors\n",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyArray")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," (and many others) admit a ",(0,i.kt)("strong",{parentName:"p"},"monad instance")," and"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"flatten")," is the most peculiar operation of monads")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),". A common synonym of ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten")," is ",(0,i.kt)("strong",{parentName:"p"},"join"),"."),(0,i.kt)("p",null,"So, what is a monad?"),(0,i.kt)("p",null,"Here is how they are often presented..."),(0,i.kt)("h2",{id:"monad-definition"},"Monad Definition"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Definition"),". A monad is defined by three things:"),(0,i.kt)("p",null,"(1) a type constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," admitting a functor instance"),(0,i.kt)("p",null,"(2) a function ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," (also called ",(0,i.kt)("strong",{parentName:"p"},"pure")," or ",(0,i.kt)("strong",{parentName:"p"},"return"),") with the following signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"of: <A>(a: A) => M<A>\n")),(0,i.kt)("p",null,"(3) a ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," function (also called ",(0,i.kt)("strong",{parentName:"p"},"flatMap")," or ",(0,i.kt)("strong",{parentName:"p"},"bind"),") with the following signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"chain: <A, B>(f: (a: A) => M<B>) => (ma: M<A>) => M<B>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," functions need to obey three laws:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain(of) \u2218 f = f")," (",(0,i.kt)("strong",{parentName:"li"},"Left identity"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain(f) \u2218 of = f")," (",(0,i.kt)("strong",{parentName:"li"},"Right identity"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain(h) \u2218 (chain(g) \u2218 f) = chain((chain(h) \u2218 g)) \u2218 f")," (",(0,i.kt)("strong",{parentName:"li"},"Associativity"),")")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," are all effectful functions and ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2218")," is the usual function composition."),(0,i.kt)("p",null,"When I saw this definition for the first time I had many questions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"why exactly those two operation ",(0,i.kt)("inlineCode",{parentName:"li"},"of")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"chain"),"? and why to they have those signatures?"),(0,i.kt)("li",{parentName:"ul"},'why do they have those synonyms like "pure" or "flatMap"?'),(0,i.kt)("li",{parentName:"ul"},"why does laws need to hold true? What do they mean?"),(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"flatten")," is so important for monads, why it doesn't compare in its definition?")),(0,i.kt)("p",null,"This chapter will try to answer all of these questions."),(0,i.kt)("p",null,"Let's get back to the core problem: what is the composition of two effectful functions ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),"?"),(0,i.kt)("img",{src:"images/kleisli_arrows.png",alt:"two Kleisli arrows, what's their composition?",width:"450px"}),(0,i.kt)("center",null,"(two Kleisli Arrows)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),". An effectful function is also called ",(0,i.kt)("strong",{parentName:"p"},"Kleisli arrow"),"."),(0,i.kt)("p",null,"For the time being I don't even know the ",(0,i.kt)("strong",{parentName:"p"},"type")," of such composition."),(0,i.kt)("p",null,"But we've already seen some abstractions that talks specifically about composition. Do you remember what we said about categories?"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Categories capture the essence of composition")),(0,i.kt)("p",null,"We can transform our problem into a category problem, meaning: can we find a category that models the composition of Kleisli arrows?"),(0,i.kt)("h2",{id:"the-kleisli-category"},"The Kleisli category"),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/kleisli.jpg",width:"300",alt:"Heinrich Kleisli"}),(0,i.kt)("p",null,"(Heinrich Kleisli, Swiss mathematician)")),(0,i.kt)("p",null,"Let's try building a category ",(0,i.kt)("em",{parentName:"p"},"K")," (called ",(0,i.kt)("strong",{parentName:"p"},"Kleisli category"),") which contains ",(0,i.kt)("em",{parentName:"p"},"only")," Kleisli arrows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"objects")," will be the same objects of the ",(0,i.kt)("em",{parentName:"li"},"TS")," category, so all TypeScript types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"morphisms")," are built like this: every time there is a Kleisli arrow ",(0,i.kt)("inlineCode",{parentName:"li"},"f: A \u27fc M<B>")," in ",(0,i.kt)("em",{parentName:"li"},"TS")," we draw an arrow ",(0,i.kt)("inlineCode",{parentName:"li"},"f': A \u27fc B")," in ",(0,i.kt)("em",{parentName:"li"},"K"))),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/kleisli_category.png",alt:"above the TS category, below the K construction",width:"400px"}),(0,i.kt)("p",null,"(above the composition in the ",(0,i.kt)("em",{parentName:"p"},"TS")," category, below the composition in the ",(0,i.kt)("em",{parentName:"p"},"K")," construction)")),(0,i.kt)("p",null,"So what would be the composition of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," in ",(0,i.kt)("em",{parentName:"p"},"K"),"?\nIt's th red arrow called ",(0,i.kt)("inlineCode",{parentName:"p"},"h'")," in the image below:"),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/kleisli_composition.png",alt:"above the composition in the TS category, below the composition in the K construction",width:"400px"}),(0,i.kt)("p",null,"(above the composition in the ",(0,i.kt)("em",{parentName:"p"},"TS")," category, below the composition in the ",(0,i.kt)("em",{parentName:"p"},"K")," construction)")),(0,i.kt)("p",null,"Given that ",(0,i.kt)("inlineCode",{parentName:"p"},"h'")," is an arrow from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"K"),", we can find a corresponding function ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"M<C>")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"TS"),"."),(0,i.kt)("p",null,"Thus, a good candidate for the following composition of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," in ",(0,i.kt)("em",{parentName:"p"},"TS")," is still a Kleisli arrow with the following signature: ",(0,i.kt)("inlineCode",{parentName:"p"},"(a: A) => M<C>"),"."),(0,i.kt)("p",null,"Let's try implementing such a function."),(0,i.kt)("h2",{id:"defining-chain-step-by-step"},"Defining ",(0,i.kt)("inlineCode",{parentName:"h2"},"chain")," step by step"),(0,i.kt)("p",null,"The first point (1) of the monad definition tells us that ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," admits a functor instance, thus we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function to transform the function ",(0,i.kt)("inlineCode",{parentName:"p"},"g: (b: B) => M<C>")," into a function ",(0,i.kt)("inlineCode",{parentName:"p"},"map(g): (mb: M<B>) => M<M<C>>")),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/flatMap.png",alt:"where chain comes from",width:"450px"}),(0,i.kt)("p",null,"(how to obtain the ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," function)")),(0,i.kt)("p",null,"We're stuck now though: there is no legal operation for the functor instance that allows us to flatten a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"M<M<C>>")," into a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"M<C>"),", we need an additional operation, let's call it ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten"),"."),(0,i.kt)("p",null,"If we can define such operation then we can find the composition we were looking for:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"h = flatten \u2218 map(g) \u2218 f\n")),(0,i.kt)("p",null,"By joining the ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten \u2218 map(g)"),' names we get "flatMap", hence the name!'),(0,i.kt)("p",null,"Thus we can get ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," in this way"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"chain = flatten \u2218 map(g)\n")),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/chain.png",alt:"how chain operates on the function g",width:"400px"}),(0,i.kt)("p",null,"(how ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," operates on the function ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),")")),(0,i.kt)("p",null,"Now we can update our composition table"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Program f"),(0,i.kt)("th",{parentName:"tr",align:null},"Program g"),(0,i.kt)("th",{parentName:"tr",align:null},"Composition"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pure"),(0,i.kt)("td",{parentName:"tr",align:null},"pure"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"g \u2218 f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},"pure (unary)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"map(g) \u2218 f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},"pure, ",(0,i.kt)("inlineCode",{parentName:"td"},"n"),"-ary"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"liftAn(g) \u2218 f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},"effectful"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"chain(g) \u2218 f"))))),(0,i.kt)("p",null,"What about ",(0,i.kt)("inlineCode",{parentName:"p"},"of"),"? Well, ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," comes from the identity morphisms in ",(0,i.kt)("em",{parentName:"p"},"K"),": for every identity morphism 1",(0,i.kt)("sub",null,"A")," in ",(0,i.kt)("em",{parentName:"p"},"K")," there has to be a corresponding function from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"M<A>")," (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"of: <A>(a: A) => M<A>"),")."),(0,i.kt)("center",null,(0,i.kt)("img",{src:"images/of.png",alt:"where of comes from",width:"300px"}),(0,i.kt)("p",null,"(where ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," comes from)")),(0,i.kt)("p",null,"The fact that ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," is the neutral element for ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," allows this kind of flux control (pretty common):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"pipe(\n  mb,\n  M.chain((b) => (predicate(b) ? M.of(b) : g(b)))\n)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"predicate: (b: B) => boolean"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mb: M<B>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g: (b: B) => M<B>"),"."),(0,i.kt)("p",null,"Last question: where do the laws come from? They are nothing else but the categorical laws in ",(0,i.kt)("em",{parentName:"p"},"K")," translated to ",(0,i.kt)("em",{parentName:"p"},"TS"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Law"),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"th"},"K")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"th"},"TS")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Left identity"),(0,i.kt)("td",{parentName:"tr",align:null},"1",(0,i.kt)("sub",null,"B")," \u2218 ",(0,i.kt)("inlineCode",{parentName:"td"},"f'")," = ",(0,i.kt)("inlineCode",{parentName:"td"},"f'")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"chain(of) \u2218 f = f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Right identity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"f'")," \u2218 1",(0,i.kt)("sub",null,"A")," = ",(0,i.kt)("inlineCode",{parentName:"td"},"f'")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"chain(f) \u2218 of = f"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Associativity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"h' \u2218 (g' \u2218 f') = (h' \u2218 g') \u2218 f'")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"chain(h) \u2218 (chain(g) \u2218 f) = chain((chain(h) \u2218 g)) \u2218 f"))))),(0,i.kt)("p",null,"If we now go back to the examples that showed the problem with nested contexts we can solve them using ",(0,i.kt)("inlineCode",{parentName:"p"},"chain"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as A from 'fp-ts/ReadonlyArray'\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly followers: ReadonlyArray<User>\n}\n\nconst getFollowers = (user: User): ReadonlyArray<User> => user.followers\n\ndeclare const user: User\n\nconst followersOfFollowers: ReadonlyArray<User> = pipe(\n  user,\n  getFollowers,\n  A.chain(getFollowers)\n)\n\nconst inverse = (n: number): O.Option<number> =>\n  n === 0 ? O.none : O.some(1 / n)\n\nconst inverseHead: O.Option<number> = pipe([1, 2, 3], A.head, O.chain(inverse))\n")),(0,i.kt)("p",null,"Let's see how ",(0,i.kt)("inlineCode",{parentName:"p"},"chain")," is implemented for the usual type constructors we've already seen:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = ReadonlyArray"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// transforms functions `B -> ReadonlyArray<C>` into functions `ReadonlyArray<B> -> ReadonlyArray<C>`\nconst chain = <B, C>(g: (b: B) => ReadonlyArray<C>) => (\n  mb: ReadonlyArray<B>\n): ReadonlyArray<C> => {\n  const out: Array<C> = []\n  for (const b of mb) {\n    out.push(...g(b))\n  }\n  return out\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = Option"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { match, none, Option } from 'fp-ts/Option'\n\n// transforms functions `B -> Option<C>` into functions `Option<B> -> Option<C>`\nconst chain = <B, C>(g: (b: B) => Option<C>): ((mb: Option<B>) => Option<C>) =>\n  match(() => none, g)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = IO"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\n\n// transforms functions `B -> IO<C>` into functions `IO<B> -> IO<C>`\nconst chain = <B, C>(g: (b: B) => IO<C>) => (mb: IO<B>): IO<C> => () =>\n  g(mb())()\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = Task"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Task } from 'fp-ts/Task'\n\n// transforms functions `B -> Task<C>` into functions `Task<B> -> Task<C>`\nconst chain = <B, C>(g: (b: B) => Task<C>) => (mb: Task<B>): Task<C> => () =>\n  mb().then((b) => g(b)())\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")," (",(0,i.kt)("inlineCode",{parentName:"p"},"F = Reader"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Reader } from 'fp-ts/Reader'\n\n// transforms functions `B -> Reader<R, C>` into functions `Reader<R, B> -> Reader<R, C>`\nconst chain = <B, R, C>(g: (b: B) => Reader<R, C>) => (\n  mb: Reader<R, B>\n): Reader<R, C> => (r) => g(mb(r))(r)\n")),(0,i.kt)("h2",{id:"manipulating-programs"},"Manipulating programs"),(0,i.kt)("p",null,"Let's see now, how thanks to referential transparency and the monad concept we can programmaticaly manipulate programs."),(0,i.kt)("p",null,"Here's a small program that reads / writes a file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { log } from 'fp-ts/Console'\nimport { IO, chain } from 'fp-ts/IO'\nimport { pipe } from 'fp-ts/function'\nimport * as fs from 'fs'\n\n// -----------------------------------------\n// library functions\n// -----------------------------------------\n\nconst readFile = (filename: string): IO<string> => () =>\n  fs.readFileSync(filename, 'utf-8')\n\nconst writeFile = (filename: string, data: string): IO<void> => () =>\n  fs.writeFileSync(filename, data, { encoding: 'utf-8' })\n\n// API derived from the previous functions\nconst modifyFile = (filename: string, f: (s: string) => string): IO<void> =>\n  pipe(\n    readFile(filename),\n    chain((s) => writeFile(filename, f(s)))\n  )\n\n// -----------------------------------------\n// program\n// -----------------------------------------\n\nconst program1 = pipe(\n  readFile('file.txt'),\n  chain(log),\n  chain(() => modifyFile('file.txt', (s) => s + '\\n// eof')),\n  chain(() => readFile('file.txt')),\n  chain(log)\n)\n")),(0,i.kt)("p",null,"The actions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"pipe(readFile('file.txt'), chain(log))\n")),(0,i.kt)("p",null,"is repeated more than once in the program, but given that referential transparency holds we can factor it and assign it to a constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const read = pipe(readFile('file.txt'), chain(log))\nconst modify = modifyFile('file.txt', (s) => s + '\\n// eof')\n\nconst program2 = pipe(\n  read,\n  chain(() => modify),\n  chain(() => read)\n)\n")),(0,i.kt)("p",null,"We can even define a combinator and leverage it to make the code more compact:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const interleave = <A, B>(action: IO<A>, middle: IO<B>): IO<A> =>\n  pipe(\n    action,\n    chain(() => middle),\n    chain(() => action)\n  )\n\nconst program3 = interleave(read, modify)\n")),(0,i.kt)("p",null,"Another example: implementing a function similar to Unix' ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," (the part related to the execution time) for ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import * as IO from 'fp-ts/IO'\nimport { now } from 'fp-ts/Date'\nimport { log } from 'fp-ts/Console'\nimport { pipe } from 'fp-ts/function'\n\n// logs the computation lenght in milliseconds\nexport const time = <A>(ma: IO.IO<A>): IO.IO<A> =>\n  pipe(\n    now,\n    IO.chain((startMillis) =>\n      pipe(\n        ma,\n        IO.chain((a) =>\n          pipe(\n            now,\n            IO.chain((endMillis) =>\n              pipe(\n                log(`Elapsed: ${endMillis - startMillis}`),\n                IO.map(() => a)\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Digression"),". As you can notice, using ",(0,i.kt)("inlineCode",{parentName:"p"},"chain"),' when it is required to maintain a scope leads to verbose code.\nIn languages that support monadic style natively there is often syntax support that goes by the name of "do notation" which eases this kind of situations.'),(0,i.kt)("p",null,"Let's see a Haskell example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'now :: IO Int\nnow = undefined -- `undefined` in Haskell is equivalent to TypeScript\'s declare\n\nlog :: String -> IO ()\nlog = undefined\n\ntime :: IO a -> IO a\ntime ma = do\n  startMillis <- now\n  a <- ma\n  endMillis <- now\n  log ("Elapsed:" ++ show (endMillis - startMillis))\n  return a\n')),(0,i.kt)("p",null,"TypeScript does not support such syntax, but it can be emulated with something similar:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { log } from 'fp-ts/Console'\nimport { now } from 'fp-ts/Date'\nimport { pipe } from 'fp-ts/function'\nimport * as IO from 'fp-ts/IO'\n\n// logs the computation lenght in milliseconds\nexport const time = <A>(ma: IO.IO<A>): IO.IO<A> =>\n  pipe(\n    IO.Do,\n    IO.bind('startMillis', () => now),\n    IO.bind('a', () => ma),\n    IO.bind('endMillis', () => now),\n    IO.chainFirst(({ endMillis, startMillis }) =>\n      log(`Elapsed: ${endMillis - startMillis}`)\n    ),\n    IO.map(({ a }) => a)\n  )\n")),(0,i.kt)("p",null,"Let's see a usage example of the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," combinator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { randomInt } from 'fp-ts/Random'\nimport { Monoid, concatAll } from 'fp-ts/Monoid'\nimport { replicate } from 'fp-ts/ReadonlyArray'\n\nconst fib = (n: number): number => (n <= 1 ? 1 : fib(n - 1) + fib(n - 2))\n\n// launches `fib` with a random integer between 30 and 35\n// logging both the input and output\nconst randomFib: IO.IO<void> = pipe(\n  randomInt(30, 35),\n  IO.chain((n) => log([n, fib(n)]))\n)\n\n// a monoid instance for `IO<void>`\nconst MonoidIO: Monoid<IO.IO<void>> = {\n  concat: (first, second) => () => {\n    first()\n    second()\n  },\n  empty: IO.of(undefined)\n}\n\n// executes `n` times the `mv` computation\nconst replicateIO = (n: number, mv: IO.IO<void>): IO.IO<void> =>\n  concatAll(MonoidIO)(replicate(n, mv))\n\n// -------------------\n// usage example\n// -------------------\n\ntime(replicateIO(3, randomFib))()\n/*\n[ 31, 2178309 ]\n[ 33, 5702887 ]\n[ 30, 1346269 ]\nElapsed: 89\n*/\n")),(0,i.kt)("p",null,"Logs also the partial:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"time(replicateIO(3, time(randomFib)))()\n/*\n[ 33, 5702887 ]\nElapsed: 54\n[ 30, 1346269 ]\nElapsed: 13\n[ 32, 3524578 ]\nElapsed: 39\nElapsed: 106\n*/\n")),(0,i.kt)("p",null,"One of the most interesting aspects of working with the monadic interface (",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"of"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"chain"),") is the possibility to inject dependencies which the program needs, including the ",(0,i.kt)("strong",{parentName:"p"},"way of concatenating different computations"),"."),(0,i.kt)("p",null,"To see that, let's refactor the small program that reads and writes a file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\nimport { pipe } from 'fp-ts/function'\n\n// -----------------------------------------\n// Deps interface, what we would call a \"port\" in the Hexagonal Architecture\n// -----------------------------------------\n\ninterface Deps {\n  readonly readFile: (filename: string) => IO<string>\n  readonly writeFile: (filename: string, data: string) => IO<void>\n  readonly log: <A>(a: A) => IO<void>\n  readonly chain: <A, B>(f: (a: A) => IO<B>) => (ma: IO<A>) => IO<B>\n}\n\n// -----------------------------------------\n// program\n// -----------------------------------------\n\nconst program4 = (D: Deps) => {\n  const modifyFile = (filename: string, f: (s: string) => string) =>\n    pipe(\n      D.readFile(filename),\n      D.chain((s) => D.writeFile(filename, f(s)))\n    )\n\n  return pipe(\n    D.readFile('file.txt'),\n    D.chain(D.log),\n    D.chain(() => modifyFile('file.txt', (s) => s + '\\n// eof')),\n    D.chain(() => D.readFile('file.txt')),\n    D.chain(D.log)\n  )\n}\n\n// -----------------------------------------\n// a `Deps` instance, what we would call an \"adapter\" in the Hexagonal Architecture\n// -----------------------------------------\n\nimport * as fs from 'fs'\nimport { log } from 'fp-ts/Console'\nimport { chain } from 'fp-ts/IO'\n\nconst DepsSync: Deps = {\n  readFile: (filename) => () => fs.readFileSync(filename, 'utf-8'),\n  writeFile: (filename: string, data: string) => () =>\n    fs.writeFileSync(filename, data, { encoding: 'utf-8' }),\n  log,\n  chain\n}\n\n// dependency injection\nprogram4(DepsSync)()\n")),(0,i.kt)("p",null,"There's more, we can even abstract the effect in which the program runs. We can define our own ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSystem")," effect (the effect representing read-write operations over the file system):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { IO } from 'fp-ts/IO'\nimport { pipe } from 'fp-ts/function'\n\n// -----------------------------------------\n// our program's effect\n// -----------------------------------------\n\ninterface FileSystem<A> extends IO<A> {}\n\n// -----------------------------------------\n// dependencies\n// -----------------------------------------\n\ninterface Deps {\n  readonly readFile: (filename: string) => FileSystem<string>\n  readonly writeFile: (filename: string, data: string) => FileSystem<void>\n  readonly log: <A>(a: A) => FileSystem<void>\n  readonly chain: <A, B>(\n    f: (a: A) => FileSystem<B>\n  ) => (ma: FileSystem<A>) => FileSystem<B>\n}\n\n// -----------------------------------------\n// program\n// -----------------------------------------\n\nconst program4 = (D: Deps) => {\n  const modifyFile = (filename: string, f: (s: string) => string) =>\n    pipe(\n      D.readFile(filename),\n      D.chain((s) => D.writeFile(filename, f(s)))\n    )\n\n  return pipe(\n    D.readFile('file.txt'),\n    D.chain(D.log),\n    D.chain(() => modifyFile('file.txt', (s) => s + '\\n// eof')),\n    D.chain(() => D.readFile('file.txt')),\n    D.chain(D.log)\n  )\n}\n")),(0,i.kt)("p",null,"With a simple change in the definition of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSystem")," effect. we can modify the program to make it run asynchronously"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"// -----------------------------------------\n// our program's effect\n// -----------------------------------------\n\n-interface FileSystem<A> extends IO<A> {}\n+interface FileSystem<A> extends Task<A> {}\n")),(0,i.kt)("p",null,"now all there's left is to modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deps")," instance to adapt to the new definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Task } from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\n\n// -----------------------------------------\n// our program's effect (modified)\n// -----------------------------------------\n\ninterface FileSystem<A> extends Task<A> {}\n\n// -----------------------------------------\n// dependencies (NOT modified)\n// -----------------------------------------\n\ninterface Deps {\n  readonly readFile: (filename: string) => FileSystem<string>\n  readonly writeFile: (filename: string, data: string) => FileSystem<void>\n  readonly log: <A>(a: A) => FileSystem<void>\n  readonly chain: <A, B>(\n    f: (a: A) => FileSystem<B>\n  ) => (ma: FileSystem<A>) => FileSystem<B>\n}\n\n// -----------------------------------------\n// program (NOT modified)\n// -----------------------------------------\n\nconst program5 = (D: Deps) => {\n  const modifyFile = (filename: string, f: (s: string) => string) =>\n    pipe(\n      D.readFile(filename),\n      D.chain((s) => D.writeFile(filename, f(s)))\n    )\n\n  return pipe(\n    D.readFile('file.txt'),\n    D.chain(D.log),\n    D.chain(() => modifyFile('file.txt', (s) => s + '\\n// eof')),\n    D.chain(() => D.readFile('file.txt')),\n    D.chain(D.log)\n  )\n}\n\n// -----------------------------------------\n// a `Deps` instance (modified)\n// -----------------------------------------\n\nimport * as fs from 'fs'\nimport { log } from 'fp-ts/Console'\nimport { chain, fromIO } from 'fp-ts/Task'\n\nconst DepsAsync: Deps = {\n  readFile: (filename) => () =>\n    new Promise((resolve) =>\n      fs.readFile(filename, { encoding: 'utf-8' }, (_, s) => resolve(s))\n    ),\n  writeFile: (filename: string, data: string) => () =>\n    new Promise((resolve) => fs.writeFile(filename, data, () => resolve())),\n  log: (a) => fromIO(log(a)),\n  chain\n}\n\n// dependency injection\nprogram5(DepsAsync)()\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Quiz"),". The previous examples overlook, on purpose, possible errors. Example give: the file we're operating on may not exist at all. How could we modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSystem")," effect to take this into account?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Task } from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\n\n// -----------------------------------------\n// our program's effect (modified)\n// -----------------------------------------\n\ninterface FileSystem<A> extends Task<E.Either<Error, A>> {}\n\n// -----------------------------------------\n// dependencies (NOT modified)\n// -----------------------------------------\n\ninterface Deps {\n  readonly readFile: (filename: string) => FileSystem<string>\n  readonly writeFile: (filename: string, data: string) => FileSystem<void>\n  readonly log: <A>(a: A) => FileSystem<void>\n  readonly chain: <A, B>(\n    f: (a: A) => FileSystem<B>\n  ) => (ma: FileSystem<A>) => FileSystem<B>\n}\n\n// -----------------------------------------\n// program (NOT modified)\n// -----------------------------------------\n\nconst program5 = (D: Deps) => {\n  const modifyFile = (filename: string, f: (s: string) => string) =>\n    pipe(\n      D.readFile(filename),\n      D.chain((s) => D.writeFile(filename, f(s)))\n    )\n\n  return pipe(\n    D.readFile('-.txt'),\n    D.chain(D.log),\n    D.chain(() => modifyFile('file.txt', (s) => s + '\\n// eof')),\n    D.chain(() => D.readFile('file.txt')),\n    D.chain(D.log)\n  )\n}\n\n// -----------------------------------------\n// `Deps` instance (modified)\n// -----------------------------------------\n\nimport * as fs from 'fs'\nimport { log } from 'fp-ts/Console'\nimport { chain, fromIO } from 'fp-ts/TaskEither'\n\nconst DepsAsync: Deps = {\n  readFile: (filename) => () =>\n    new Promise((resolve) =>\n      fs.readFile(filename, { encoding: 'utf-8' }, (err, s) => {\n        if (err !== null) {\n          resolve(E.left(err))\n        } else {\n          resolve(E.right(s))\n        }\n      })\n    ),\n  writeFile: (filename: string, data: string) => () =>\n    new Promise((resolve) =>\n      fs.writeFile(filename, data, (err) => {\n        if (err !== null) {\n          resolve(E.left(err))\n        } else {\n          resolve(E.right(undefined))\n        }\n      })\n    ),\n  log: (a) => fromIO(log(a)),\n  chain\n}\n\n// dependency injection\nprogram5(DepsAsync)().then(console.log)\n")))}c.isMDXComponent=!0}}]);