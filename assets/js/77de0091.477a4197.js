"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[570],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>g});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=o.createContext({}),s=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=s(e.components);return o.createElement(p.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(t),d=a,g=c["".concat(p,".").concat(d)]||c[d]||u[d]||i;return t?o.createElement(g,r(r({ref:n},m),{},{components:t})):o.createElement(g,r({ref:n},m))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=d;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=t[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9778:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var o=t(7462),a=(t(7294),t(3905));const i={},r="Modeling composition through Monoids",l={unversionedId:"Modeling composition through Monoids",id:"Modeling composition through Monoids",title:"Modeling composition through Monoids",description:"Let's recap what we have seen till now.",source:"@site/docs/5. Modeling composition through Monoids.md",sourceDirName:".",slug:"/Modeling composition through Monoids",permalink:"/functional-programming/Modeling composition through Monoids",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/5. Modeling composition through Monoids.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Modelling equivalence with Eq",permalink:"/functional-programming/Modelling equivalence with Eq"},next:{title:"Pure and partial functions",permalink:"/functional-programming/Pure and partial functions"}},p={},s=[{value:"The <code>concatAll</code> function",id:"the-concatall-function",level:2},{value:"Product monoid",id:"product-monoid",level:2}],m={toc:s},c="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"modeling-composition-through-monoids"},"Modeling composition through Monoids"),(0,a.kt)("p",null,"Let's recap what we have seen till now."),(0,a.kt)("p",null,"We have seen how an ",(0,a.kt)("strong",{parentName:"p"},"algebra")," is a combination of:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"some type ",(0,a.kt)("inlineCode",{parentName:"li"},"A")),(0,a.kt)("li",{parentName:"ul"},"some operations involving the type ",(0,a.kt)("inlineCode",{parentName:"li"},"A")),(0,a.kt)("li",{parentName:"ul"},"some laws and properties for that combination.")),(0,a.kt)("p",null,"The first algebra we have seen has been the magma, an algebra defined on some type A equipped with one operation called ",(0,a.kt)("inlineCode",{parentName:"p"},"concat"),". There were no laws involved in ",(0,a.kt)("inlineCode",{parentName:"p"},"Magma<A>")," the only requirement we had was that the ",(0,a.kt)("inlineCode",{parentName:"p"},"concat")," operation had to be ",(0,a.kt)("em",{parentName:"p"},"closed")," on ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," meaning that the result:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"concat(first: A, second: A) => A\n")),(0,a.kt)("p",null,"has still to be an element of the ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," type."),(0,a.kt)("p",null,"Later on we have seen how adding one simple requirement, ",(0,a.kt)("em",{parentName:"p"},"associativity"),", allowed some ",(0,a.kt)("inlineCode",{parentName:"p"},"Magma<A>")," to be further refined as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup<A>"),", and how associativity captures the possibility of computations to be parallelized."),(0,a.kt)("p",null,"Now we're going to add another condition on Semigroup."),(0,a.kt)("p",null,"Given a ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup")," defined on some set ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," with some ",(0,a.kt)("inlineCode",{parentName:"p"},"concat")," operation, if there is some element in ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," \u2013 we'll call this element ",(0,a.kt)("em",{parentName:"p"},"empty")," \u2013 such as for every element ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," the two following equations hold true:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Right identity"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"concat(a, empty) = a")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Left identity"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"concat(empty, a) = a"))),(0,a.kt)("p",null,"then the ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup")," is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"Monoid"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": We'll call the ",(0,a.kt)("inlineCode",{parentName:"p"},"empty")," element ",(0,a.kt)("strong",{parentName:"p"},"unit")," for the rest of this section. There's other synonyms in literature, some of the most common ones are ",(0,a.kt)("em",{parentName:"p"},"neutral element")," and ",(0,a.kt)("em",{parentName:"p"},"identity element"),"."),(0,a.kt)("p",null,"We have seen how in TypeScript ",(0,a.kt)("inlineCode",{parentName:"p"},"Magma"),"s and ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup"),"s, can be modeled with ",(0,a.kt)("inlineCode",{parentName:"p"},"interface"),"s, so it should not come as a surprise that the very same can be done for ",(0,a.kt)("inlineCode",{parentName:"p"},"Monoid"),"s."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Semigroup } from 'fp-ts/Semigroup'\n\ninterface Monoid<A> extends Semigroup<A> {\n  readonly empty: A\n}\n")),(0,a.kt)("p",null,"Many of the semigroups we have seen in the previous sections can be extended to become ",(0,a.kt)("inlineCode",{parentName:"p"},"Monoid"),"s. All we need to find is some element of type ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," for which the Right and Left identities hold true."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid } from 'fp-ts/Monoid'\n\n/** number `Monoid` under addition */\nconst MonoidSum: Monoid<number> = {\n  concat: (first, second) => first + second,\n  empty: 0\n}\n\n/** number `Monoid` under multiplication */\nconst MonoidProduct: Monoid<number> = {\n  concat: (first, second) => first * second,\n  empty: 1\n}\n\nconst MonoidString: Monoid<string> = {\n  concat: (first, second) => first + second,\n  empty: ''\n}\n\n/** boolean monoid under conjunction */\nconst MonoidAll: Monoid<boolean> = {\n  concat: (first, second) => first && second,\n  empty: true\n}\n\n/** boolean monoid under disjunction */\nconst MonoidAny: Monoid<boolean> = {\n  concat: (first, second) => first || second,\n  empty: false\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Quiz"),". In the semigroup section we have seen how the type ",(0,a.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<string>")," admits a ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup")," instance:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Semigroup } from 'fp-ts/Semigroup'\n\nconst Semigroup: Semigroup<ReadonlyArray<string>> = {\n  concat: (first, second) => first.concat(second)\n}\n")),(0,a.kt)("p",null,"Can you find the ",(0,a.kt)("inlineCode",{parentName:"p"},"unit")," for this semigroup? If so, can we generalize the result not just for ",(0,a.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<string>")," but ",(0,a.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<A>")," as well?"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Quiz")," (more complex). Prove that given a monoid, there can only be one unit."),(0,a.kt)("p",null,"The consequence of the previous proof is that there can be only one unit per monoid, once we find one we can stop searching."),(0,a.kt)("p",null,"We have seen how each semigroup was a magma, but not every magma was a semigroup. In the same way, each monoid is a semigroup, but not every semigroup is a monoid."),(0,a.kt)("center",null,(0,a.kt)("img",{src:"images/monoid.png",width:"300",alt:"Magma vs Semigroup vs Monoid"})),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("p",null,"Let's consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'fp-ts/function'\nimport { intercalate } from 'fp-ts/Semigroup'\nimport * as S from 'fp-ts/string'\n\nconst SemigroupIntercalate = pipe(S.Semigroup, intercalate('|'))\n\nconsole.log(S.Semigroup.concat('a', 'b')) // => 'ab'\nconsole.log(SemigroupIntercalate.concat('a', 'b')) // => 'a|b'\nconsole.log(SemigroupIntercalate.concat('a', '')) // => 'a|'\n")),(0,a.kt)("p",null,"Note how for this Semigroup there's no such ",(0,a.kt)("inlineCode",{parentName:"p"},"empty")," value of type ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," such as ",(0,a.kt)("inlineCode",{parentName:"p"},"concat(a, empty) = a"),"."),(0,a.kt)("p",null,'And now one final, slightly more "exotic" example, involving functions:'),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"endomorphism")," is a function whose input and output type is the same:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type Endomorphism<A> = (a: A) => A\n")),(0,a.kt)("p",null,"Given a type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),", all endomorphisms defined on ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," are a monoid, such as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("inlineCode",{parentName:"li"},"concat")," operation is the usual function composition"),(0,a.kt)("li",{parentName:"ul"},"the unit, our ",(0,a.kt)("inlineCode",{parentName:"li"},"empty")," value is the identity function")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Endomorphism, flow, identity } from 'fp-ts/function'\nimport { Monoid } from 'fp-ts/Monoid'\n\nexport const getEndomorphismMonoid = <A>(): Monoid<Endomorphism<A>> => ({\n  concat: flow,\n  empty: identity\n})\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": The ",(0,a.kt)("inlineCode",{parentName:"p"},"identity")," function has one, and only one possible implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const identity = (a: A) => a\n")),(0,a.kt)("p",null,"Whatever value we pass in input, it gives us the same value in output."),(0,a.kt)("h2",{id:"the-concatall-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"concatAll")," function"),(0,a.kt)("p",null,"One great property of monoids, compared to semigrops, is that the concatenation of multiple elements becomes even easier: it is not necessary anymore to provide an initial value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { concatAll } from 'fp-ts/Monoid'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\nimport * as B from 'fp-ts/boolean'\n\nconsole.log(concatAll(N.MonoidSum)([1, 2, 3, 4])) // => 10\nconsole.log(concatAll(N.MonoidProduct)([1, 2, 3, 4])) // => 24\nconsole.log(concatAll(S.Monoid)(['a', 'b', 'c'])) // => 'abc'\nconsole.log(concatAll(B.MonoidAll)([true, false, true])) // => false\nconsole.log(concatAll(B.MonoidAny)([true, false, true])) // => true\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Quiz"),". Why is the initial value not needed anymore?"),(0,a.kt)("h2",{id:"product-monoid"},"Product monoid"),(0,a.kt)("p",null,"As we have already seen with semigroups, it is possible to define a monoid instance for a ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," if we are able to define a monoid instance for each of its fields."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid, struct } from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\n\ntype Point = {\n  readonly x: number\n  readonly y: number\n}\n\nconst Monoid: Monoid<Point> = struct({\n  x: N.MonoidSum,\n  y: N.MonoidSum\n})\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),". There is a combinator similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," that works with tuples: ",(0,a.kt)("inlineCode",{parentName:"p"},"tuple"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Monoid, tuple } from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\n\ntype Point = readonly [number, number]\n\nconst Monoid: Monoid<Point> = tuple(N.MonoidSum, N.MonoidSum)\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Quiz"),'. Is it possible to define a "free monoid" for a generic type ',(0,a.kt)("inlineCode",{parentName:"p"},"A"),"?"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Demo")," (implementing a system to draw geoetric shapes on canvas)"))}u.isMDXComponent=!0}}]);